{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\udd8b express-openapi-validator","text":"<p>An OpenApi validator for ExpressJS that automatically validates API requests and responses using an OpenAPI 3 specification.</p> <p> </p> <p>\ud83e\udd8bexpress-openapi-validator is an unopinionated library that integrates with new and existing API applications. express-openapi-validator lets you write code the way you want; it does not impose any coding convention or project layout. Simply, install the validator onto your express app, point it to your OpenAPI 3.0.x or 3.1.x specification, then define and implement routes the way you prefer. See an example.</p> <p>Features:</p> <ul> <li>\u2714\ufe0f request validation</li> <li>\u2714\ufe0f response validation (json only)</li> <li>\ud83d\udc6e security validation / custom security functions</li> <li>\ud83d\udc7d 3rd party / custom formats / custom data serialization-deserialization</li> <li>\ud83e\uddf5 optionally auto-map OpenAPI endpoints to Express handler functions</li> <li>\u2702\ufe0f \\$ref support; split specs over multiple files</li> <li>\ud83c\udf88 file upload</li> <li>\u270f\ufe0f OpenAPI 3.0.x and 3.1.x spec support</li> <li>\u2728 Express 4 and 5 support</li> </ul> <p>Docs:</p> <ul> <li>\ud83d\udcd6 documentation</li> </ul> <p>Noteworthy:</p> <ul> <li>Express 5 support available in <code>&gt;=v5.5.0</code>!</li> <li>OAS 3.1 supporr available in <code>&gt;=v5.4.0</code>!</li> <li>NestJS Koa and Fastify now available! \ud83d\ude80</li> </ul> <p>Support the project:</p> <p></p>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"about-who-are-we/","title":"Links","text":"<ul> <li>Contribute to express-openapi-validator: https://github.com/cdimascio/express-openapi-validator</li> <li>Edit this documentation: https://github.com/cdimascio/express-openapi-validator-documentation</li> <li>https://github.com/cdimascio</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#q-how-do-i-match-paths-like-those-described-in-rfc-6570","title":"Q: How do I match paths, like those described in RFC-6570?","text":"<p>OpenAPI 3.0 does not support RFC-6570. That said, we provide a minimalistic mechanism that conforms syntactically to OpenAPI 3 and accomplishes a common use case. For example, matching file paths and storing the matched path in <code>req.params</code></p> <p>Using the following OpenAPI 3.x definition</p> <pre><code>/files/{path}*:\n  get:\n    parameters:\n      - name: path\n        in: path\n        required: true\n        schema:\n          type: string\n</code></pre> <p>With the following Express route definition</p> <pre><code>  app.get(`/files/:path(*)`, (req, res) =&gt; { /* do stuff */ }`\n</code></pre> <p>A path like <code>/files/some/long/path</code> will pass validation. The Express <code>req.params.path</code> property will hold the value <code>some/long/path</code>.</p>"},{"location":"faq/#q-can-i-use-discriminators-with-oneof-and-anyof","title":"Q: Can I use discriminators with <code>oneOf</code> and <code>anyOf</code>?","text":"<ul> <li>By default, only top-level discriminators are supported. See the top-level discriminator example.</li> <li>To also enable deep discriminator support (nested within <code>oneOf</code> / <code>anyOf</code>), set the <code>discriminator</code> option under <code>validateRequests</code>:</li> </ul>"},{"location":"faq/#appuse-openapivalidatormiddleware-apispec-validaterequests-discriminator-true-other-options","title":"<pre><code>app.use(\n    OpenApiValidator.middleware({\n        apiSpec,\n        validateRequests: {\n            discriminator: true,\n            //... other options\n        }\n    })\n);\n</code></pre>","text":""},{"location":"faq/#q-what-happened-to-the-securityhandlers-property","title":"Q: What happened to the <code>securityHandlers</code> property?","text":"<p>In v3, <code>securityHandlers</code> have been replaced by <code>validateSecurity.handlers</code>. To use v3 security handlers, move your existing security handlers to the new property. No other change is required. Note that the v2 <code>securityHandlers</code> property is supported in v3, but deprecated</p>"},{"location":"faq/#q-what-happened-to-the-multeropts-property","title":"Q: What happened to the <code>multerOpts</code> property?","text":"<p>In v3, <code>multerOpts</code> have been replaced by <code>fileUploader</code>. In order to use the v3 <code>fileUploader</code>, move your multer options to <code>fileUploader</code> No other change is required. Note that the v2 <code>multerOpts</code> property is supported in v3, but deprecated</p>"},{"location":"faq/#q-i-can-disallow-unknown-query-parameters-with-allowunknownqueryparameters-false-how-can-disallow-unknown-body-parameters","title":"Q: I can disallow unknown query parameters with <code>allowUnknownQueryParameters: false</code>. How can disallow unknown body parameters?","text":"<p>Add <code>additionalProperties: false</code> when describing e.g a <code>requestBody</code> to ensure that additional properties are not allowed. For example:</p> <pre><code>Pet:\nadditionalProperties: false\nrequired:\n  - name\nproperties:\n  name:\n    type: string\n  type:\n    type: string\n</code></pre>"},{"location":"faq/#q-can-i-use-express-openapi-validator-with-swagger-ui-express","title":"Q: Can I use <code>express-openapi-validator</code> with <code>swagger-ui-express</code>?","text":"<p>Yes. Be sure to <code>use</code> the <code>swagger-ui-express</code> serve middleware prior to installing <code>OpenApiValidator</code>. This will ensure that <code>swagger-ui-express</code> is able to fully prepare the spec before before OpenApiValidator attempts to use it. For example:</p> <pre><code>const swaggerUi = require('swagger-ui-express')\nconst OpenApiValidator = require('express-openapi-validator')\n\n...\n\napp.use('/', swaggerUi.serve, swaggerUi.setup(documentation))\n\napp.use(OpenApiValidator.middleware({\n  apiSpec, // api spec JSON object\n  //... other options\n  }\n}))\n</code></pre>"},{"location":"faq/#q-i-have-a-handler-function-defined-on-an-expressrouter-if-i-call-reqparams-each-param-value-has-type-string-if-i-define-same-handler-function-on-an-expressapplication-each-value-in-reqparams-is-already-coerced-to-the-type-declare-in-my-spec-why-not-coerce-thesef-values-on-an-expressrouter","title":"Q: I have a handler function defined on an <code>express.Router</code>. If i call <code>req.params</code> each param value has type <code>string</code>. If i define same handler function on an <code>express.Application</code>, each value in <code>req.params</code> is already coerced to the type declare in my spec. Why not coerce theseF values on an <code>express.Router</code>?","text":"<p>First, it's important to note that this behavior does not impact validation. The validator will validate against the type defined in your spec.</p> <p>In order to modify the <code>req.params</code>, express requires that a param handler be registered e.g. <code>app.param(...)</code> or <code>router.param(...)</code>. Since <code>app</code> is available to middleware functions, the validator registers an <code>app.param</code> handler to coerce and modify the values of <code>req.params</code> to their declared types. Unfortunately, express does not provide a means to determine the current router from a middleware function, hence the validator is unable to register the same param handler on an express router. Ultimately, this means if your handler function is defined on <code>app</code>, the values of <code>req.params</code> will be coerced to their declared types. If your handler function is declare on an <code>express.Router</code>, the values of <code>req.params</code> values will be of type <code>string</code> (You must coerce them e.g. <code>parseInt(req.params.id)</code>).</p>"},{"location":"gc-guides/","title":"Guides","text":"<p>To get up and running, follow the three steps below. For a more in depth step-by-step guide, choose on of the following:</p> <ul> <li> <p> Standard Guide</p> <p>Automatically validate your new or existing express API against an OpenAPI specification using express-openapi-validator middleware.</p> <p> Get Started</p> </li> <li> <p> Operation Handler Guide</p> <p>Automatically validate your API, mapping each OpenAPI path to its corresponding JavaScript/TypeScript function using our OpenAPI vendor extension!</p> <p> Get Started</p> </li> </ul>"},{"location":"gc-guides/#validation-options","title":"Validation Options","text":"<p>See options</p>"},{"location":"gc-guides/#curl-examples","title":"<code>curl</code> examples","text":"<p>See examples</p>"},{"location":"gc-installation/","title":"Installation","text":"<p>An OpenApi validator for ExpressJS that automatically validates API requests and responses using an OpenAPI 3 specification.</p> <p> </p>"},{"location":"gc-installation/#install","title":"Install","text":""},{"location":"gc-installation/#with-npm","title":"with npm","text":"<pre><code>npm install express-openapi-validator\n</code></pre>"},{"location":"gc-installation/#with-yarn","title":"with yarn","text":"<pre><code>yarn add express-openapi-validator\n</code></pre>"},{"location":"gc-installation/#openapi-31-support-alpha","title":"OpenAPI 3.1 (support) alpha","text":"<p>Replace  with the latest alpha version <pre><code>npm install express-openapi-validator@6.0.0-alpha.&lt;X&gt;\n</code></pre>"},{"location":"gc-installation/#upgrading-from-3x","title":"Upgrading from 3.x","text":"<p>Note</p> <p>In v4.x.x, the validator is installed as standard connect middleware using <code>app.use(...) and/or router.use(...)</code> (example). This differs from the v3.x.x the installation which required the <code>install</code> method(s). The <code>install</code> methods no longer exist in v4.</p>"},{"location":"gc-quick-start/","title":"Quick start","text":""},{"location":"gc-quick-start/#quick-start","title":"Quick Start","text":""},{"location":"gc-quick-start/#1-requireimport-the-openapi-validator","title":"1. Require/import the openapi validator","text":"<p>Note</p> <p>Important: Ensure express is configured with all relevant body parsers. Body parser middleware functions must be specified prior to any validated routes. See an example.</p> <pre><code>const OpenApiValidator = require('express-openapi-validator');\n</code></pre> <p>or</p> <pre><code>import * as OpenApiValidator from 'express-openapi-validator';\n</code></pre>"},{"location":"gc-quick-start/#2-install-the-middleware","title":"2. Install the middleware","text":"<pre><code>app.use(\n  OpenApiValidator.middleware({\n    apiSpec: './openapi.yaml',\n    validateRequests: true, // (default)\n    validateResponses: true, // false by default\n  }),\n);\n</code></pre>"},{"location":"gc-quick-start/#3-register-an-error-handler","title":"3. Register an error handler","text":"<pre><code>app.use((err, req, res, next) =&gt; {\n  // format error\n  res.status(err.status || 500).json({\n    message: err.message,\n    errors: err.errors,\n  });\n});\n</code></pre>"},{"location":"gc-quick-start/#advanced-usage-options","title":"Advanced Usage (options)","text":"<p>See Advanced Usage options to:</p> <ul> <li>inline api specs as JSON.</li> <li>configure request/response validation options</li> <li>customize authentication with security validation <code>handlers</code>.</li> <li>use OpenAPI 3.0.x 3rd party and custom formats.</li> <li>tweak the file upload configuration.</li> <li>ignore routes</li> <li>and more...</li> </ul>"},{"location":"guide-multiple-specs/","title":"Validate Multiple API specs","text":""},{"location":"guide-multiple-specs/#multiple-validators-and-api-specs","title":"Multiple Validators and API specs","text":"<p>It may be useful to serve multiple APIs with separate specs via single service. An example might be an API that serves both <code>v1</code> and <code>v2</code> from the same service. The sample code below shows how one might accomplish this.</p> <p>See complete example</p> <pre><code>const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst http = require('http');\nconst OpenApiValidator = require('express-openapi-validator');\n\napp = express();\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.text());\napp.use(bodyParser.json());\n\nconst versions = [1, 2];\n\nfor (const v of versions) {\n  const apiSpec = path.join(__dirname, `api.v${v}.yaml`);\n  app.use(\n    OpenApiValidator.middleware({\n      apiSpec,\n    }),\n  );\n\n  routes(app, v);\n}\n\nhttp.createServer(app).listen(3000);\nconsole.log('Listening on port 3000');\n\nfunction routes(app, v) {\n  if (v === 1) routesV1(app);\n  if (v === 2) routesV2(app);\n}\n\nfunction routesV1(app) {\n  const v = '/v1';\n  app.post(`${v}/pets`, (req, res, next) =&gt; {\n    res.json({ ...req.body });\n  });\n  app.get(`${v}/pets`, (req, res, next) =&gt; {\n    res.json([\n      {\n        id: 1,\n        name: 'happy',\n        type: 'cat',\n      },\n    ]);\n  });\n\n  app.use((err, req, res, next) =&gt; {\n    // format error\n    res.status(err.status || 500).json({\n      message: err.message,\n      errors: err.errors,\n    });\n  });\n}\n\nfunction routesV2(app) {\n  const v = '/v2';\n  app.get(`${v}/pets`, (req, res, next) =&gt; {\n    res.json([\n      {\n        pet_id: 1,\n        pet_name: 'happy',\n        pet_type: 'kitty',\n      },\n    ]);\n  });\n  app.post(`${v}/pets`, (req, res, next) =&gt; {\n    res.json({ ...req.body });\n  });\n\n  app.use((err, req, res, next) =&gt; {\n    // format error\n    res.status(err.status || 500).json({\n      message: err.message,\n      errors: err.errors,\n    });\n  });\n}\n\nmodule.exports = app;\n</code></pre>"},{"location":"guide-operation-handlers/","title":"API Server with Operation Handlers","text":"<p>If you prefer not to manually map your OpenAPI endpoints to Express handler functions, <code>express-openapi-validator</code> can do it for you automatically! This example demonstrates how to utilize express-openapi-validator's OpenAPI <code>x-eov-operation-*</code> vendor extensions.</p>"},{"location":"guide-operation-handlers/#source-code-and-openapi-spec","title":"Source Code and OpenAPI Spec","text":"<p>See the full example with source code and the OpenAPI spec. - Source Code - OpenAPI Spec</p>"},{"location":"guide-operation-handlers/#overview","title":"Overview","text":"<p>Here's a quick overview of how to use operation handlers:</p> <ol> <li> <p>Specify the <code>operationHandlers</code> option to set the base directory that contains your operation handler files.     <pre><code>app.use(\n  OpenApiValidator.middleware({\n    apiSpec,\n    operationHandlers: path.join(__dirname),\n  })\n);\n</code></pre></p> </li> <li> <p>Use the <code>x-eov-operation-id</code> OpenAPI vendor extension or <code>operationId</code> to specify the ID of the operation handler to invoke.     <pre><code>/ping:\n  get:\n    # operationId: ping\n    x-eov-operation-id: ping\n</code></pre></p> </li> <li> <p>Use the <code>x-eov-operation-handler</code> OpenAPI vendor extension to specify a path (relative to <code>operationHandlers</code>) to the module that contains the handler for this operation.     <pre><code>/ping:\n  get:\n    x-eov-operation-id: ping\n    x-eov-operation-handler: routes/ping # no .js or .ts extension\n</code></pre></p> </li> <li> <p>Create the express handler module, e.g., <code>routes/ping.js</code>.     <pre><code>module.exports = {\n  // the express handler implementation for ping\n  ping: (req, res) =&gt; res.status(200).send('pong'),\n};\n</code></pre></p> </li> </ol> <p>Note: A file may contain one or many handlers.</p>"},{"location":"guide-operation-handlers/#code-snippets","title":"Code Snippets","text":""},{"location":"guide-operation-handlers/#appjs","title":"app.js","text":"<pre><code>const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst logger = require('morgan');\nconst http = require('http');\nconst OpenApiValidator = require('express-openapi-validator');\n\nconst port = 3000;\nconst app = express();\nconst apiSpec = path.join(__dirname, 'api.yaml');\n\n// Install bodyParsers for the request types your API will support\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.text());\napp.use(bodyParser.json());\n\napp.use(logger('dev'));\n\napp.use('/spec', express.static(apiSpec));\n\n// Install the OpenApiValidator on your express app\napp.use(\n  OpenApiValidator.middleware({\n    apiSpec,\n    validateResponses: true, // default false\n    // Provide the base path to the operation handlers directory\n    operationHandlers: path.join(__dirname), // default false\n  })\n);\n\n// With auto-wired operation handlers, you don't have to declare your routes!\n// See api.yaml for x-eov-* vendor extensions\n\n// Create a custom error handler\napp.use((err, req, res, next) =&gt; {\n  // format errors\n  res.status(err.status || 500).json({\n    message: err.message,\n    errors: err.errors,\n  });\n});\n\nhttp.createServer(app).listen(port);\nconsole.log(`Listening on port ${port}`);\n\nmodule.exports = app;\n</code></pre>"},{"location":"guide-operation-handlers/#apiyaml","title":"api.yaml","text":"<pre><code>/ping:\n  get:\n    description: |\n      ping then pong!\n    # OpenAPI's operationId may be used to specify the operation id\n    operationId: ping\n    # x-eov-operation-id may be used to specify the operation id\n    # Used when operationId is omitted. Overrides operationId when both are specified\n    x-eov-operation-id: ping\n    # specifies the path to the operation handler.\n    # the path is relative to the operationHandlers option\n    # e.g. operations/base/path/routes/ping.js\n    x-eov-operation-handler: routes/ping\n    responses:\n      '200':\n        description: OK\n        # ...\n</code></pre>"},{"location":"guide-operation-handlers/#pingjs","title":"ping.js","text":"<pre><code>module.exports = {\n  // ping must match operationId or x-eov-operation-id above\n  // note that x-eov-operation-id overrides operationId\n  ping: (req, res) =&gt; res.status(200).send('pong'),\n};\n</code></pre>"},{"location":"guide-standard/","title":"Standard Guide","text":""},{"location":"guide-standard/#overview","title":"Overview","text":"<p>This guide will walk you through the process of integrating <code>express-openapi-validator</code> into your Express application to ensure that your API adheres to your OpenAPI specification.</p>"},{"location":"guide-standard/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have Node.js and npm installed. You can install them from https://nodejs.org/.</p>"},{"location":"guide-standard/#complete-source-code","title":"Complete source code","text":"<p>See the complete source code and OpenAPI spec</p>"},{"location":"guide-standard/#step-1-set-up-your-express-application","title":"Step 1: Set Up Your Express Application","text":"<p>Start by creating a basic Express application. In your project directory, create a file (e.g., <code>app.js</code>) and add the following code:</p> <pre><code>const express = require('express');\nconst path = require('path');\nconst http = require('http');\nconst app = express();\n</code></pre> <p>This code imports the necessary modules and initializes an Express application.</p>"},{"location":"guide-standard/#step-2-configure-body-parsers","title":"Step 2: Configure Body Parsers","text":"<p>Set up body parsers for the request body types you expect. This must be done prior to defining your API endpoints. Add the following code:</p> <pre><code>app.use(express.json());\napp.use(express.text());\napp.use(express.urlencoded({ extended: false }));\n</code></pre>"},{"location":"guide-standard/#step-3-serve-the-openapi-specification-optional","title":"Step 3: Serve the OpenAPI Specification (Optional)","text":"<p>If you want to serve your OpenAPI specification, add the following code (optional):</p> <pre><code>const spec = path.join(__dirname, 'api.yaml');\napp.use('/spec', express.static(spec));\n</code></pre> <p>Replace 'api.yaml' with the path to your OpenAPI specification file.</p>"},{"location":"guide-standard/#step-4-install-and-use-express-openapi-validator-middleware","title":"Step 4: Install and Use express-openapi-validator Middleware","text":"<p>Now, install the <code>express-openapi-validator</code> middleware onto your Express app. Add the following code:</p> <pre><code>const OpenApiValidator = require('express-openapi-validator');\n\napp.use(\n  OpenApiValidator.middleware({\n    apiSpec: './api.yaml',\n    validateResponses: true,\n  })\n);\n</code></pre> <p>Replace <code>./api.yaml</code> with the path to your OpenAPI specification file.</p>"},{"location":"guide-standard/#step-5-define-your-api-endpoints","title":"Step 5: Define Your API Endpoints","text":"<p>Now, define your routes using Express. Here's an example:</p> <pre><code>app.get('/v1/pets', function (req, res, next) {\n  res.json([\n    { id: 1, type: 'cat', name: 'max' },\n    { id: 2, type: 'cat', name: 'mini' },\n  ]);\n});\n\napp.post('/v1/pets', function (req, res, next) {\n  res.json({ name: 'sparky', type: 'dog' });\n});\n\napp.get('/v1/pets/:id', function (req, res, next) {\n  res.json({ id: req.params.id, type: 'dog', name: 'sparky' });\n});\n\n// Additional route for uploading files\napp.post('/v1/pets/:id/photos', function (req, res, next) {\n  // Handle file upload logic here\n});\n\n// 6. Create an Express error handler\napp.use((err, req, res, next) =&gt; {\n  // 7. Customize errors\n  console.error(err);\n  res.status(err.status || 500).json({\n    message: err.message,\n    errors: err.errors,\n  });\n});\n</code></pre>"},{"location":"guide-standard/#step-6-start-the-server","title":"Step 6: Start the Server","text":"<p>Finally, create an HTTP server and listen on port 3000:</p> <pre><code>http.createServer(app).listen(3000);\n</code></pre> <p>Save the file, and in your terminal, run:</p> <pre><code>node app.js\n</code></pre> <p>Visit http://localhost:3000/spec to see your OpenAPI specification, and start testing your API!</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2019 Carmine M. DiMascio</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"ref-base-url/","title":"Base URL","text":""},{"location":"ref-base-url/#the-base-url","title":"The Base URL","text":"<p>The validator will only validate requests, securities, and responses that are under the server's base URL.</p> <p>This is useful for those times when the API and frontend are being served by the same application. (More detail about the base URL.)</p> <pre><code>servers:\n  - url: https://api.example.com/v1\n</code></pre> <p>The validation applies to all paths defined under this base URL. Routes in your app that are _not_se URL\u2014such as pages\u2014will not be validated.</p> URL Validated? <code>https://api.example.com/v1/users</code> <code>https://api.example.com/index.html</code> no; not under the base URL <p>In some cases, it may be necessary to skip validation for paths under the base url. To do this, use the <code>ignorePaths</code> option.</p>"},{"location":"ref-main/","title":"Ref main","text":""},{"location":"ref-main/#title-index","title":"title: Index","text":""},{"location":"ref-security-handlers/","title":"Security Handlers","text":""},{"location":"ref-security-handlers/#security-handlers","title":"Security handlers","text":"<p>Note: security <code>handlers</code> are an optional component. security <code>handlers</code> provide a convenience, whereby the request, declared scopes, and the security schema itself are provided as parameters to each security <code>handlers</code> callback that you define. The code you write in each callback can then perform authentication and authorization checks. Note that the same can be achieved using standard Express middleware. The difference is that security <code>handlers</code> provide you the OpenAPI schema data described in your specification_. Ultimately, this means, you don't have to duplicate that information in your code.</p> <p>All in all, security <code>handlers</code> are purely optional and are provided as a convenience.</p> <p>Security handlers specify a set of custom security handlers to be used to validate security i.e. authentication and authorization. If a security <code>handlers</code> object is specified, a handler must be defined for all securities. If security `handlers are not specified, a default handler is always used. The default handler will validate against the OpenAPI spec, then call the next middleware.</p> <p>If security <code>handlers</code> are specified, the validator will validate against the OpenAPI spec, then call the security handler providing it the Express request, the security scopes, and the security schema object.</p> <ul> <li>security <code>handlers</code> is an object that maps security keys to security handler functions. Each security key must correspond to <code>securityScheme</code> name.   The <code>validateSecurity.handlers</code> object signature is as follows:</li> </ul> <pre><code>{\n  validateSecurity: {\n    handlers: {\n      [securityKey]: function(\n        req: Express.Request,\n        scopes: string[],\n        schema: SecuritySchemeObject\n      ): void,\n    }\n  }\n}\n</code></pre> <p>SecuritySchemeObject</p> <p>For example:</p> <pre><code>validateSecurity: {\n  handlers: {\n    ApiKeyAuth: function(req, scopes, schema) {\n      console.log('apikey handler throws custom error', scopes, schema);\n      throw Error('my message');\n    },\n  }\n}\n</code></pre> <p>The express-openapi-validator performs a basic validation pass prior to delegating to security handlers. If basic validation passes, security handler function(s) are invoked.</p> <p>In order to signal an auth failure, the security handler function must either:</p> <ol> <li><code>throw { status: 403, message: 'forbidden' }</code></li> <li><code>throw Error('optional message')</code></li> <li><code>return false</code></li> <li>return a promise which resolves to <code>false</code> e.g <code>Promise.resolve(false)</code></li> <li>return a promise rejection e.g.</li> <li><code>Promise.reject({ status: 401, message: 'yikes' });</code></li> <li><code>Promise.reject(Error('optional 'message')</code></li> <li><code>Promise.reject(false)</code></li> </ol> <p>Note: error status <code>401</code> is returned, unless option <code>i.</code> above is used</p> <p>Some examples:</p> <pre><code>validateSecurity: {\n  handlers: {\n    ApiKeyAuth: (req, scopes, schema) =&gt; {\n      throw Error('my message');\n    },\n    OpenID: async (req, scopes, schema) =&gt; {\n      throw { status: 403, message: 'forbidden' }\n    },\n    BasicAuth: (req, scopes, schema) =&gt; {\n      return Promise.resolve(false);\n    },\n    ...\n  }\n}\n</code></pre> <p>In order to grant authz, the handler function must either:</p> <ul> <li><code>return true</code></li> <li>return a promise which resolves to <code>true</code></li> </ul> <p>Some examples</p> <pre><code>validateSecurity: {\n  handlers: {\n    ApiKeyAuth: (req, scopes, schema) =&gt; {\n      return true;\n    },\n    BearerAuth: async (req, scopes, schema) =&gt; {\n      return true;\n    },\n    ...\n  }\n}\n</code></pre> <p>Each security <code>handlers</code>' <code>securityKey</code> must match a <code>components/securitySchemes</code> property</p> <pre><code>components:\n  securitySchemes:\n    ApiKeyAuth: # &lt;-- Note this name must be used as the name handler function property\n      type: apiKey\n      in: header\n      name: X-API-Key\n</code></pre> <p>See OpenAPI 3 authentication for <code>securityScheme</code> and <code>security</code> documentation See examples from unit tests</p>"},{"location":"rest/","title":"Rest","text":""},{"location":"rest/#install","title":"Install","text":"<pre><code>npm install express-openapi-validator\n</code></pre>"},{"location":"rest/#usage","title":"Usage","text":"<ol> <li>Require/import the openapi validator</li> </ol> <pre><code>const OpenApiValidator = require('express-openapi-validator');\n</code></pre> <p>or</p> <pre><code>import * as OpenApiValidator from 'express-openapi-validator';\n</code></pre> <ol> <li>Install the middleware</li> </ol> <pre><code>app.use(\n  OpenApiValidator.middleware({\n    apiSpec: './openapi.yaml',\n    validateRequests: true, // (default)\n    validateResponses: true, // false by default\n  }),\n);\n</code></pre> <ol> <li>Register an error handler</li> </ol> <pre><code>app.use((err, req, res, next) =&gt; {\n  // format error\n  res.status(err.status || 500).json({\n    message: err.message,\n    errors: err.errors,\n  });\n});\n</code></pre> <p>Important: Ensure express is configured with all relevant body parsers. Body parser middleware functions must be specified prior to any validated routes. See an example.</p>"},{"location":"rest/#upgrading-from-3x","title":"Upgrading from 3.x","text":"<p>In v4.x.x, the validator is installed as standard connect middleware using <code>app.use(...) and/or router.use(...)</code> (example). This differs from the v3.x.x the installation which required the <code>install</code> method(s). The <code>install</code> methods no longer exist in v4.</p>"},{"location":"rest/#usage-options","title":"Usage (options)","text":"<p>See Advanced Usage options to:</p> <ul> <li>inline api specs as JSON.</li> <li>configure request/response validation options</li> <li>customize authentication with security validation <code>handlers</code>.</li> <li>use OpenAPI 3.0.x 3rd party and custom formats.</li> <li>tweak the file upload configuration.</li> <li>ignore routes</li> <li>and more...</li> </ul>"},{"location":"rest/#example-express-api-server","title":"Example Express API Server","text":"<p>The following demonstrates how to use express-openapi-validator to auto validate requests and responses. It also includes file upload!</p> <p>See the complete source code and OpenAPI spec for the example below:</p> <pre><code>const express = require('express');\nconst path = require('path');\nconst http = require('http');\nconst app = express();\n\n// 1. Import the express-openapi-validator library\nconst OpenApiValidator = require('express-openapi-validator');\n\n// 2. Set up body parsers for the request body types you expect\n//    Must be specified prior to endpoints in 5.\napp.use(express.json());\napp.use(express.text());\napp.use(express.urlencoded({ extended: false }));\n\n// 3. (optionally) Serve the OpenAPI spec\nconst spec = path.join(__dirname, 'api.yaml');\napp.use('/spec', express.static(spec));\n\n// 4. Install the OpenApiValidator onto your express app\napp.use(\n  OpenApiValidator.middleware({\n    apiSpec: './api.yaml',\n    validateResponses: true, // &lt;-- to validate responses\n  }),\n);\n\n// 5. Define routes using Express\napp.get('/v1/pets', function (req, res, next) {\n  res.json([\n    { id: 1, type: 'cat', name: 'max' },\n    { id: 2, type: 'cat', name: 'mini' },\n  ]);\n});\n\napp.post('/v1/pets', function (req, res, next) {\n  res.json({ name: 'sparky', type: 'dog' });\n});\n\napp.get('/v1/pets/:id', function (req, res, next) {\n  res.json({ id: req.params.id, type: 'dog', name: 'sparky' });\n});\n\n// 5a. Define route(s) to upload file(s)\napp.post('/v1/pets/:id/photos', function (req, res, next) {\n  // files are found in req.files\n  // non-file multipart params can be found as such: req.body['my-param']\n  res.json({\n    files_metadata: req.files.map((f) =&gt; ({\n      originalname: f.originalname,\n      encoding: f.encoding,\n      mimetype: f.mimetype,\n      // Buffer of file conents\n      buffer: f.buffer,\n    })),\n  });\n});\n\n// 6. Create an Express error handler\napp.use((err, req, res, next) =&gt; {\n  // 7. Customize errors\n  console.error(err); // dump error to console for debug\n  res.status(err.status || 500).json({\n    message: err.message,\n    errors: err.errors,\n  });\n});\n\nhttp.createServer(app).listen(3000);\n</code></pre>"},{"location":"rest/#example-express-api-server-with-operationhandlers","title":"Example Express API Server: with operationHandlers","text":"<p>Don't want to manually map your OpenAPI endpoints to Express handler functions? express-openapi-validator can do it for you, automatically!</p> <p>Use express-openapi-validator's OpenAPI <code>x-eov-operation-*</code> vendor extensions. See a full example with source code and an OpenAPI spec</p> <p>Here's the gist</p> <ul> <li>First, specify the <code>operationHandlers</code> option to set the base directory that contains your operation handler files.</li> </ul> <pre><code>app.use(\n  OpenApiValidator.middleware({\n    apiSpec,\n    operationHandlers: path.join(__dirname),\n  }),\n);\n</code></pre> <ul> <li>Next, use the <code>x-eov-operation-id</code> OpenAPI vendor extension or <code>operationId</code> to specify the id of operation handler to invoke.</li> </ul> <pre><code>/ping:\n  get:\n    # operationId: ping\n    x-eov-operation-id: ping\n</code></pre> <ul> <li>Next, use the <code>x-eov-operation-handler</code> OpenAPI vendor extension to specify a path (relative to <code>operationHandlers</code>) to the module that contains the handler for this operation.</li> </ul> <pre><code>/ping:\n  get:\n    x-eov-operation-id: ping\n    x-eov-operation-handler: routes/ping # no .js or .ts extension\n</code></pre> <ul> <li>Finally, create the express handler module e.g. <code>routes/ping.js</code></li> </ul> <pre><code>module.exports = {\n  // the express handler implementation for ping\n  ping: (req, res) =&gt; res.status(200).send('pong'),\n};\n</code></pre> <p>Note: A file may contain one or many handlers.</p> <p>Below are some code snippets:</p> <p>app.js</p> <pre><code>const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst logger = require('morgan');\nconst http = require('http');\nconst OpenApiValidator = require('express-openapi-validator');\n\nconst port = 3000;\nconst app = express();\nconst apiSpec = path.join(__dirname, 'api.yaml');\n\n// 1. Install bodyParsers for the request types your API will support\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.text());\napp.use(bodyParser.json());\n\napp.use(logger('dev'));\n\napp.use('/spec', express.static(apiSpec));\n\n//  2. Install the OpenApiValidator on your express app\napp.use(\n  OpenApiValidator.middleware({\n    apiSpec,\n    validateResponses: true, // default false\n    // 3. Provide the base path to the operation handlers directory\n    operationHandlers: path.join(__dirname), // default false\n  }),\n);\n\n// 4. Woah sweet! With auto-wired operation handlers, I don't have to declare my routes!\n//    See api.yaml for x-eov-* vendor extensions\n\n// 5. Create a custom error handler\napp.use((err, req, res, next) =&gt; {\n  // format errors\n  res.status(err.status || 500).json({\n    message: err.message,\n    errors: err.errors,\n  });\n});\n\nhttp.createServer(app).listen(port);\nconsole.log(`Listening on port ${port}`);\n\nmodule.exports = app;\n</code></pre> <p>api.yaml</p> <pre><code>/ping:\n  get:\n    description: |\n      ping then pong!\n    # OpenAPI's operationId may be used to to specify the operation id\n    operationId: ping\n    # x-eov-operation-id may be used to specify the operation id\n    # Used when operationId is omitted. Overrides operationId when both are specified\n    x-eov-operation-id: ping\n    # specifies the path to the operation handler.\n    # the path is relative to the operationHandlers option\n    # e.g. operations/base/path/routes/ping.js\n    x-eov-operation-handler: routes/ping\n    responses:\n      '200':\n        description: OK\n        # ...\n</code></pre> <p>ping.js</p> <pre><code>module.exports = {\n  // ping must match operationId or x-eov-operation-id above\n  // note that x-eov-operation-id overrides operationId\n  ping: (req, res) =&gt; res.status(200).send('pong'),\n};\n</code></pre>"},{"location":"rest/#api-validation-response-examples","title":"API Validation Response Examples","text":""},{"location":"rest/#validates-a-query-parameter-with-a-value-constraint","title":"Validates a query parameter with a value constraint","text":"<pre><code>curl -s http://localhost:3000/v1/pets/as |jq\n{\n  \"message\": \"request.params.id should be integer\",\n  \"errors\": [\n    {\n      \"path\": \".params.id\",\n      \"message\": \"should be integer\",\n      \"errorCode\": \"type.openapi.validation\"\n    }\n  ]\n}\n</code></pre>"},{"location":"rest/#validates-a-query-parameter-with-a-range-constraint","title":"Validates a query parameter with a range constraint","text":"<pre><code> curl -s 'http://localhost:3000/v1/pets?limit=25' |jq\n{\n  \"message\": \"request.query should have required property 'type', request.query.limit should be &lt;= 20\",\n  \"errors\": [\n    {\n      \"path\": \".query.type\",\n      \"message\": \"should have required property 'type'\",\n      \"errorCode\": \"required.openapi.validation\"\n    },\n    {\n      \"path\": \".query.limit\",\n      \"message\": \"should be &lt;= 20\",\n      \"errorCode\": \"maximum.openapi.validation\"\n    }\n  ]\n}\n</code></pre>"},{"location":"rest/#validates-securities-eg-api-key","title":"Validates securities e.g. API Key","text":"<pre><code> curl -s --request POST \\\n  --url http://localhost:3000/v1/pets \\\n  --data '{}' |jq\n{\n  \"message\": \"'X-API-Key' header required\",\n  \"errors\": [\n    {\n      \"path\": \"/v1/pets\",\n      \"message\": \"'X-API-Key' header required\"\n    }\n  ]\n}\n</code></pre> <p>Providing the header passes OpenAPI validation.</p> <p>Note: that your Express middleware or endpoint logic can then provide additional checks.</p> <pre><code>curl -XPOST http://localhost:3000/v1/pets \\\n  --header 'X-Api-Key: XXXXX' \\\n  --header 'content-type: application/json' \\\n  -d '{\"name\": \"spot\"}' | jq\n\n{\n  \"id\": 4,\n  \"name\": \"spot\"\n}\n</code></pre>"},{"location":"rest/#validates-content-type","title":"Validates content-type","text":"<pre><code>curl -s --request POST \\\n  --url http://localhost:3000/v1/pets \\\n  --header 'content-type: application/xml' \\\n  --header 'x-api-key: XXXX' \\\n  --data '{\n        \"name\": \"test\"\n}' |jq\n  \"message\": \"unsupported media type application/xml\",\n  \"errors\": [\n    {\n      \"path\": \"/v1/pets\",\n      \"message\": \"unsupported media type application/xml\"\n    }\n  ]\n}\n</code></pre>"},{"location":"rest/#validates-a-post-request-body","title":"Validates a POST request body","text":"<pre><code>curl -s --request POST \\\n  --url http://localhost:3000/v1/pets \\\n  --header 'content-type: application/json' \\\n  --header 'x-api-key: XXXX' \\\n  --data '{}'|jq\n{\n  \"message\": \"request.body should have required property 'name'\",\n  \"errors\": [\n    {\n      \"path\": \".body.name\",\n      \"message\": \"should have required property 'name'\",\n      \"errorCode\": \"required.openapi.validation\"\n    }\n  ]\n}\n</code></pre>"},{"location":"rest/#file-upload-out-of-the-box","title":"File Upload (out of the box)","text":"<pre><code>curl -XPOST http://localhost:3000/v1/pets/10/photos -F file=@app.js|jq\n{\n  \"files_metadata\": [\n    {\n      \"originalname\": \"app.js\",\n      \"encoding\": \"7bit\",\n      \"mimetype\": \"application/octet-stream\"\n    }\n  ]\n}\n</code></pre>"},{"location":"rest/#validates-responses-optional","title":"Validates responses (optional)","text":"<p>Errors in response validation return <code>500</code>, not of <code>400</code></p> <p><code>/v1/pets/99</code> will return a response that does not match the spec</p> <pre><code> curl -s 'http://localhost:3000/v1/pets/99' |jq\n{\n  \"message\": \".response should have required property 'name', .response should have required property 'id'\",\n  \"errors\": [\n    {\n      \"path\": \".response.name\",\n      \"message\": \"should have required property 'name'\",\n      \"errorCode\": \"required.openapi.validation\"\n    },\n    {\n      \"path\": \".response.id\",\n      \"message\": \"should have required property 'id'\",\n      \"errorCode\": \"required.openapi.validation\"\n    }\n  ]\n}\n</code></pre>"},{"location":"rest/#and-much-more-try-it-out","title":"...and much more. Try it out!","text":""},{"location":"rest/#response-status-codes","title":"Response status codes","text":"<p>express-openapi-validator returns the following error codes depending on the situation.</p>"},{"location":"rest/#request-validation-validaterequeststrue","title":"Request validation (validateRequests=true)","text":"status when <code>400</code> (bad request) a validation error is encountered <code>401</code> (unauthorized) a security / authentication errors is encountered e.g. missing api-key, Authorization header, etc <code>404</code> (not found) a path is not found i.e. not declared in the API spec <code>405</code> (method not allowed) a path is declared in the API spec, but a no schema is provided for the method"},{"location":"rest/#response-validation-validateresponsestrue","title":"Response validation (validateResponses=true)","text":"status when <code>500</code> (internal server error) any error is encountered by the validator"},{"location":"rest/#advanced-usage","title":"Advanced Usage","text":""},{"location":"rest/#openapivalidator-middleware-options","title":"OpenApiValidator Middleware Options","text":"<p>express-openapi validator provides a good deal of flexibility via its options.</p> <p>Options are provided via the options object. Options take the following form:</p> <pre><code>OpenApiValidator.middleware({\n  apiSpec: './openapi.yaml',\n  validateRequests: true,\n  validateResponses: true,\n  validateApiSpec: true,\n  validateSecurity: {\n    handlers: {\n      ApiKeyAuth: (req, scopes, schema) =&gt; {\n        throw { status: 401, message: 'sorry' }\n      }\n    }\n  },\n  validateFormats: 'fast',\n  formats: [{\n    name: 'my-custom-format',\n    type: 'string' | 'number',\n    validate: (value: any) =&gt; boolean,\n  }],\n  unknownFormats: ['phone-number', 'uuid'],\n  serDes: [\n    OpenApiValidator.serdes.dateTime,\n    OpenApiValidator.serdes.date,\n    {\n      format: 'mongo-objectid',\n      deserialize: (s) =&gt; new ObjectID(s),\n      serialize: (o) =&gt; o.toString(),\n    },\n  ],\n  operationHandlers: false | 'operations/base/path' | { ... },\n  ignorePaths: /.*\\/pets$/,\n  ignoreUndocumented: false,\n  fileUploader: { ... } | true | false,\n  $refParser: {\n    mode: 'bundle'\n  },\n});\n</code></pre>"},{"location":"rest/#apispec-required","title":"\u25aa\ufe0f apiSpec (required)","text":"<p>Specifies the path to an OpenAPI 3 specification or a JSON object representing the OpenAPI 3 specification</p> <pre><code>apiSpec: './path/to/my-openapi-spec.yaml',\n</code></pre> <p>or</p> <pre><code>  apiSpec: {\n  openapi: '3.0.1',\n  info: {...},\n  servers: [...],\n  paths: {...},\n  components: {\n    responses: {...},\n    schemas: {...}\n  }\n}\n</code></pre>"},{"location":"rest/#validaterequests-optional","title":"\u25aa\ufe0f validateRequests (optional)","text":"<p>Determines whether the validator should validate requests.</p> <ul> <li><code>true</code> (default) - validate requests.</li> <li><code>false</code> - do not validate requests.</li> <li><code>{ ... }</code> - validate requests with options</li> </ul> <p>allowUnknownQueryParameters:</p> <ul> <li><code>true</code> - enables unknown/undeclared query parameters to pass validation</li> <li><code>false</code> - (default) fail validation if an unknown query parameter is present</li> </ul> <p>For example:</p> <pre><code>validateRequests: {\n  allowUnknownQueryParameters: true,\n}\n</code></pre> <p><code>allowUnknownQueryParameters</code> is set for the entire validator. It can be overwritten per-operation using   a custom property <code>x-allow-unknown-query-parameters</code>.</p> <p>For example to allow unknown query parameters on ONLY a single endpoint:</p> <pre><code>paths:\n  /allow_unknown:\n    get:\n      x-allow-unknown-query-parameters: true\n      parameters:\n        - name: value\n          in: query\n          schema:\n            type: string\n      responses:\n        200:\n          description: success\n</code></pre> <p>coerceTypes:</p> <p>Determines whether the validator will coerce the request body. Request query and path params, headers, cookies are coerced by default and this setting does not affect that.</p> <p>See additional details on coercion and limitiations.</p> <p>Options:</p> <ul> <li><code>true</code> - coerce scalar data types.</li> <li><code>false</code> - (default) do not coerce types. (more strict, safer)</li> <li><code>\"array\"</code> - in addition to coercions between scalar types, coerce scalar data to an array with one element and vice versa (as required by the schema).</li> </ul> <p>For example:</p> <pre><code>validateRequests: {\n  coerceTypes: true,\n}\n</code></pre> <p>removeAdditional:</p> <p>Determines whether to keep or remove additional properties in request body or to fail validation if schema has <code>additionalProperties</code> set to <code>false</code>. For further details, refer to AJV documentation</p> <ul> <li><code>false</code> (default) - not to remove additional properties</li> <li><code>\"all\"</code> - all additional properties are removed, regardless of additionalProperties keyword in schema (and no validation is made for them).</li> <li><code>true</code> - only additional properties with additionalProperties keyword equal to false are removed.</li> <li><code>\"failing\"</code> - additional properties that fail request schema validation will be removed (where additionalProperties keyword is false or schema).</li> </ul> <p>For example:</p> <pre><code>validateRequests: {\n  removeAdditional: true,\n}\n</code></pre>"},{"location":"rest/#validateresponses-optional","title":"\u25aa\ufe0f validateResponses (optional)","text":"<p>Determines whether the validator should validate responses. Also accepts response validation options.</p> <ul> <li><code>true</code> - validate responses in 'strict' mode i.e. responses MUST match the schema.</li> <li><code>false</code> (default) - do not validate responses</li> <li><code>{ ... }</code> - validate responses with options</li> </ul> <p>removeAdditional:</p> <ul> <li><code>\"failing\"</code> - additional properties that fail schema validation are automatically removed from the response.</li> </ul> <p>coerceTypes:</p> <ul> <li><code>true</code> - coerce scalar data types.</li> <li><code>false</code> - (default) do not coerce types. (almost always the desired behavior)</li> <li><code>\"array\"</code> - in addition to coercions between scalar types, coerce scalar data to an array with one element and vice versa (as required by the schema).</li> </ul> <p>For example:</p> <pre><code>validateResponses: {\n  removeAdditional: 'failing',\n}\n</code></pre> <p>onError:</p> <p>A function that will be invoked on response validation error, instead of the default handling. Useful if you want to log an error or emit a metric, but don't want to actually fail the request. Receives the validation error, the offending response body, and the express request object.</p> <p>For example:</p> <pre><code>validateResponses: {\n  onError: (error, body, req) =&gt; {\n    console.log(`Response body fails validation: `, error);\n    console.log(`Emitted from:`, req.originalUrl);\n    console.debug(body);\n  }\n}\n</code></pre>"},{"location":"rest/#validatesecurity-optional","title":"\u25aa\ufe0f validateSecurity (optional)","text":"<p>Determines whether the validator should validate securities e.g. apikey, basic, oauth2, openid, etc</p> <ul> <li><code>true</code> (default) - validate security</li> <li><code>false</code> - do not validate security</li> <li><code>{ ... }</code> - validate security with <code>handlers</code>. See Security handlers doc.</li> </ul> <p>handlers:</p> <p>For example:</p> <pre><code>validateSecurity: {\n  handlers: {\n    ApiKeyAuth: function(req, scopes, schema) {\n      console.log('apikey handler throws custom error', scopes, schema);\n      throw Error('my message');\n    },\n  }\n}\n</code></pre>"},{"location":"rest/#validateapispec-optional","title":"\u25aa\ufe0f validateApiSpec (optional)","text":"<p>Determines whether the validator should validate the OpenAPI specification. Useful if you are certain that the api spec is syntactically correct and want to bypass this check.</p> <p>Warning: Be certain your spec is valid. And be sure you know what you're doing! express-openapi-validator expects a valid spec. If incorrect, the validator will behave erratically and/or throw Javascript errors.</p> <ul> <li><code>true</code> (default) - validate the OpenAPI specification.</li> <li><code>false</code> - do not validate the OpenAPI specification.</li> </ul>"},{"location":"rest/#formats-optional","title":"\u25aa\ufe0f formats (optional)","text":"<p>Defines a list of custom formats.</p> <ul> <li><code>[{ ... }]</code> - array of custom format objects. Each object must have the following properties:</li> <li>name: string (required) - the format name</li> <li>validate: (v: any) =&gt; boolean (required) - the validation function</li> <li>type: 'string' | 'number' (optional) - the format's type</li> </ul> <p>e.g.</p> <pre><code>formats: [\n  {\n    name: 'my-three-digit-format',\n    type: 'number',\n    // validate returns true the number has 3 digits, false otherwise\n    validate: (v) =&gt; /^\\d{3}$/.test(v.toString()),\n  },\n  {\n    name: 'my-three-letter-format',\n    type: 'string',\n    // validate returns true the string has 3 letters, false otherwise\n    validate: (v) =&gt; /^[A-Za-z]{3}$/.test(v),\n  },\n];\n</code></pre> <p>Then use it in a spec e.g.</p> <pre><code>my_property:\n  type: string\n  format: my-three-letter-format'\n</code></pre>"},{"location":"rest/#validateformats-optional","title":"\u25aa\ufe0f validateFormats (optional)","text":"<p>Specifies the strictness of validation of string formats.</p> <ul> <li><code>\"fast\"</code> (default) - only validate syntax, but not semantics. E.g. <code>2010-13-30T23:12:35Z</code> will pass validation even though it contains month 13.</li> <li><code>\"full\"</code> - validate both syntax and semantics. Illegal dates will not pass.</li> <li><code>false</code> - do not validate formats at all.</li> </ul>"},{"location":"rest/#unknownformats-optional","title":"\u25aa\ufe0f unknownFormats (optional)","text":"<p>Defines how the validator should behave if an unknown or custom format is encountered.</p> <ul> <li><code>true</code> (default) - When an unknown format is encountered, the validator will report a 400 error.</li> <li><code>[string]</code> (recommended for unknown formats) - An array of unknown format names that will be ignored by the validator. This option can be used to allow usage of third party schemas with format(s), but still fail if another unknown format is used.   e.g.</li> </ul> <pre><code>unknownFormats: ['phone-number', 'uuid'],\n</code></pre> <ul> <li><code>\"ignore\"</code> - to log warning during schema compilation and always pass validation. This option is not recommended, as it allows to mistype format name and it won't be validated without any error message.</li> </ul>"},{"location":"rest/#serdes-optional","title":"\u25aa\ufe0f serDes (optional)","text":"<p>Defines custom serialization and deserialization behavior for schemas of type <code>string</code> that declare a <code>format</code>. By default, <code>Date</code> objects are serialized as <code>string</code> when a schema's <code>type</code> is <code>string</code> and <code>format</code> is <code>date</code> or <code>date-time</code>.</p> <p>e.g.</p> <pre><code>// If `serDes` is not specified, the following behavior is default\nserDes: [\n  OpenApiValidator.serdes.dateTime.serializer,\n  OpenApiValidator.serdes.date.serializer,\n],\n</code></pre> <p>To create custom serializers and/or deserializers, define:</p> <ul> <li><code>format</code> (required) - a custom 'unknown' format that triggers the serializer and/or deserializer</li> <li><code>deserialize</code> (optional) - upon receiving a request, transform a string property to an object. Deserialization occurs after request schema validation.</li> <li><code>serialize</code> (optional) - before sending a response, transform an object to string. Serialization occurs after response schema validation</li> <li><code>jsonType</code> (optional, default 'object') - set to override for deserialized types that are not 'object', eg 'array'</li> </ul> <p>e.g.</p> <pre><code>serDes: [\n   // installs dateTime serializer and deserializer\n  OpenApiValidator.serdes.dateTime,\n  // installs date serializer and deserializer\n  OpenApiValidator.serdes.date,\n  // custom serializer and deserializer for the custom format, mongo-objectid\n  {\n    format: 'mongo-objectid',\n    deserialize: (s) =&gt; new ObjectID(s),\n    serialize: (o) =&gt; o.toString(),\n  },\n],\n</code></pre> <p>The mongo serializers will trigger on the following schema:</p> <pre><code>type: string\nformat: mongo-objectid\n</code></pre> <p>See mongo-serdes-js for additional (de)serializers including MongoDB <code>ObjectID</code>, <code>UUID</code>, ...</p>"},{"location":"rest/#operationhandlers-optional","title":"\u25aa\ufe0f operationHandlers (optional)","text":"<p>Defines the base directory for operation handlers. This is used in conjunction with express-openapi-validator's OpenAPI vendor extensions, <code>x-eov-operation-id</code>, <code>x-eov-operation-handler</code> and OpenAPI's <code>operationId</code>. See example.</p> <p>Additionally, if you want to change how modules are resolved e.g. use dot delimited operation ids e.g. <code>path.to.module.myFunction</code>, you may optionally add a custom <code>resolver</code>. See documentation and example</p> <ul> <li><code>string</code> - the base directory containing operation handlers</li> <li><code>false</code> - (default) disable auto wired operation handlers</li> <li><code>{ ... }</code> - specifies a base directory and optionally a custom resolver</li> </ul> <p>handlers:</p> <p>For example:</p> <pre><code>operationHandlers: {\n  basePath: __dirname,\n  resolver: function (modulePath, route): express.RequestHandler {\n    ///...\n  }\n}\n</code></pre> <pre><code>operationHandlers: 'operations/base/path'\n</code></pre> <p>Note that the <code>x-eov-operation-handler</code> OpenAPI vendor extension specifies a path relative to <code>operationHandlers</code>. Thus if <code>operationHandlers</code> is <code>/handlers</code> and an <code>x-eov-operation-handler</code> has path <code>routes/ping</code>, then the handler file <code>/handlers/routes/ping.js</code> (or <code>ts</code>) is used.</p> <p>Complete example here</p> <p>api.yaml</p> <pre><code>/ping:\n  get:\n    description: |\n      ping then pong!\n    # OpenAPI's operationId may be used to to specify the operation id\n    operationId: ping\n    # x-eov-operation-id may be used to specify the operation id\n    # Used when operationId is omitted. Overrides operationId when both are specified\n    x-eov-operation-id: ping\n    # specifies the path to the operation handler.\n    # the path is relative to the operationHandlers option\n    # e.g. operations/base/path/routes/ping.js\n    x-eov-operation-handler: routes/ping\n    responses:\n      '200':\n        description: OK\n        # ...\n</code></pre> <p>routes/ping.js</p> <p><code>x-eov-operation-handler</code> specifies the path to this handlers file, <code>ping.js</code></p> <p><code>x-eov-operation-id</code> (or <code>operationId</code>) specifies operation handler's key e.g. <code>ping</code></p> <pre><code>module.exports = {\n  ping: (req, res) =&gt; res.status(200).send('pong'),\n};\n</code></pre>"},{"location":"rest/#ignorepaths-optional","title":"\u25aa\ufe0f ignorePaths (optional)","text":"<p>Defines a regular expression or function that determines whether a path(s) should be ignored. If it's a regular expression, any path that matches the regular expression will be ignored by the validator. If it's a function, it will ignore any paths that returns a truthy value.</p> <p>The following ignores any path that ends in <code>/pets</code> e.g. <code>/v1/pets</code>. As a regular expression:</p> <pre><code>ignorePaths: /.*\\/pets$/\n</code></pre> <p>or as a function:</p> <pre><code>ignorePaths: (path) =&gt; path.endsWith('/pets')\n</code></pre>"},{"location":"rest/#ignoreundocumented-optional","title":"\u25aa\ufe0f ignoreUndocumented (optional)","text":"<p>Disables any form of validation for requests which are not documented in the OpenAPI spec.</p> <p>Defaults to <code>false</code></p>"},{"location":"rest/#fileuploader-optional","title":"\u25aa\ufe0f fileUploader (optional)","text":"<p>Specifies the options to passthrough to multer. express-openapi-validator uses multer to handle file uploads. see multer opts</p> <ul> <li><code>true</code> (default) - enables multer and provides simple file(s) upload capabilities</li> <li><code>false</code> - disables file upload capability. Upload capabilities may be provided by the user</li> <li><code>{...}</code> - multer options to be passed-through to multer. see multer opts for possible options</li> </ul> <p>e.g.</p> <pre><code>fileUploader: {\n  dest: 'uploads/',\n}\n</code></pre>"},{"location":"rest/#refparsermode-optional","title":"\u25aa\ufe0f \\$refParser.mode (optional)","text":"<p>Determines how JSON schema references are resolved by the internal json-schema-ref-parser. Generally, the default mode, <code>bundle</code> is sufficient, however if you use escape characters in \\$refs, <code>dereference</code> is necessary.</p> <ul> <li><code>bundle</code> (default) - Bundles all referenced files/URLs into a single schema that only has internal $ref pointers. This eliminates the risk of circular references, but does not handle escaped characters in $refs.</li> <li><code>dereference</code> - Dereferences all $ref pointers in the JSON Schema, replacing each reference with its resolved value. Introduces risk of circular $refs. Handles escape characters in \\$refs)</li> </ul> <p>See this issue for more information.</p> <p>e.g.</p> <pre><code>$refParser: {\n  mode: 'bundle',\n}\n</code></pre>"},{"location":"rest/#coercetypes-optional-deprecated","title":"\u25aa\ufe0f coerceTypes (optional) - deprecated","text":"<p>Determines whether the validator should coerce value types to match the those defined in the OpenAPI spec. This option applies only to path params, query strings, headers, and cookies. It is highly unlikely that you will want to disable this. As such this option is deprecated and will be removed in the next major version</p> <ul> <li><code>true</code> (default) - coerce scalar data types.</li> <li><code>\"array\"</code> - in addition to coercions between scalar types, coerce scalar data to an array with one element and vice versa (as required by the schema).</li> </ul>"},{"location":"rest/#the-base-url","title":"The Base URL","text":"<p>The validator will only validate requests, securities, and responses that are under the server's base URL.</p> <p>This is useful for those times when the API and frontend are being served by the same application. (More detail about the base URL.)</p> <pre><code>servers:\n  - url: https://api.example.com/v1\n</code></pre> <p>The validation applies to all paths defined under this base URL. Routes in your app that are _not_se URL\u2014such as pages\u2014will not be validated.</p> URL Validated? <code>https://api.example.com/v1/users</code> <code>https://api.example.com/index.html</code> no; not under the base URL <p>In some cases, it may be necessary to skip validation for paths under the base url. To do this, use the <code>ignorePaths</code> option.</p>"},{"location":"rest/#security-handlers","title":"Security handlers","text":"<p>Note: security <code>handlers</code> are an optional component. security <code>handlers</code> provide a convenience, whereby the request, declared scopes, and the security schema itself are provided as parameters to each security <code>handlers</code> callback that you define. The code you write in each callback can then perform authentication and authorization checks. Note that the same can be achieved using standard Express middleware. The difference is that security <code>handlers</code> provide you the OpenAPI schema data described in your specification_. Ultimately, this means, you don't have to duplicate that information in your code.</p> <p>All in all, security <code>handlers</code> are purely optional and are provided as a convenience.</p> <p>Security handlers specify a set of custom security handlers to be used to validate security i.e. authentication and authorization. If a security <code>handlers</code> object is specified, a handler must be defined for all securities. If security `handlers are not specified, a default handler is always used. The default handler will validate against the OpenAPI spec, then call the next middleware.</p> <p>If security <code>handlers</code> are specified, the validator will validate against the OpenAPI spec, then call the security handler providing it the Express request, the security scopes, and the security schema object.</p> <ul> <li>security <code>handlers</code> is an object that maps security keys to security handler functions. Each security key must correspond to <code>securityScheme</code> name.   The <code>validateSecurity.handlers</code> object signature is as follows:</li> </ul> <pre><code>{\n  validateSecurity: {\n    handlers: {\n      [securityKey]: function(\n        req: Express.Request,\n        scopes: string[],\n        schema: SecuritySchemeObject\n      ): void,\n    }\n  }\n}\n</code></pre> <p>SecuritySchemeObject</p> <p>For example:</p> <pre><code>validateSecurity: {\n  handlers: {\n    ApiKeyAuth: function(req, scopes, schema) {\n      console.log('apikey handler throws custom error', scopes, schema);\n      throw Error('my message');\n    },\n  }\n}\n</code></pre> <p>The express-openapi-validator performs a basic validation pass prior to delegating to security handlers. If basic validation passes, security handler function(s) are invoked.</p> <p>In order to signal an auth failure, the security handler function must either:</p> <ol> <li><code>throw { status: 403, message: 'forbidden' }</code></li> <li><code>throw Error('optional message')</code></li> <li><code>return false</code></li> <li>return a promise which resolves to <code>false</code> e.g <code>Promise.resolve(false)</code></li> <li>return a promise rejection e.g.</li> <li><code>Promise.reject({ status: 401, message: 'yikes' });</code></li> <li><code>Promise.reject(Error('optional 'message')</code></li> <li><code>Promise.reject(false)</code></li> </ol> <p>Note: error status <code>401</code> is returned, unless option <code>i.</code> above is used</p> <p>Some examples:</p> <pre><code>validateSecurity: {\n  handlers: {\n    ApiKeyAuth: (req, scopes, schema) =&gt; {\n      throw Error('my message');\n    },\n    OpenID: async (req, scopes, schema) =&gt; {\n      throw { status: 403, message: 'forbidden' }\n    },\n    BasicAuth: (req, scopes, schema) =&gt; {\n      return Promise.resolve(false);\n    },\n    ...\n  }\n}\n</code></pre> <p>In order to grant authz, the handler function must either:</p> <ul> <li><code>return true</code></li> <li>return a promise which resolves to <code>true</code></li> </ul> <p>Some examples</p> <pre><code>validateSecurity: {\n  handlers: {\n    ApiKeyAuth: (req, scopes, schema) =&gt; {\n      return true;\n    },\n    BearerAuth: async (req, scopes, schema) =&gt; {\n      return true;\n    },\n    ...\n  }\n}\n</code></pre> <p>Each security <code>handlers</code>' <code>securityKey</code> must match a <code>components/securitySchemes</code> property</p> <pre><code>components:\n  securitySchemes:\n    ApiKeyAuth: # &lt;-- Note this name must be used as the name handler function property\n      type: apiKey\n      in: header\n      name: X-API-Key\n</code></pre> <p>See OpenAPI 3 authentication for <code>securityScheme</code> and <code>security</code> documentation See examples from unit tests</p>"},{"location":"rest/#example-multiple-validators-and-api-specs","title":"Example: Multiple Validators and API specs","text":"<p>It may be useful to serve multiple APIs with separate specs via single service. An example might be an API that serves both <code>v1</code> and <code>v2</code> from the same service. The sample code below shows how one might accomplish this.</p> <p>See complete example</p> <pre><code>const express = require('express');\nconst path = require('path');\nconst bodyParser = require('body-parser');\nconst http = require('http');\nconst OpenApiValidator = require('express-openapi-validator');\n\napp = express();\napp.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.text());\napp.use(bodyParser.json());\n\nconst versions = [1, 2];\n\nfor (const v of versions) {\n  const apiSpec = path.join(__dirname, `api.v${v}.yaml`);\n  app.use(\n    OpenApiValidator.middleware({\n      apiSpec,\n    }),\n  );\n\n  routes(app, v);\n}\n\nhttp.createServer(app).listen(3000);\nconsole.log('Listening on port 3000');\n\nfunction routes(app, v) {\n  if (v === 1) routesV1(app);\n  if (v === 2) routesV2(app);\n}\n\nfunction routesV1(app) {\n  const v = '/v1';\n  app.post(`${v}/pets`, (req, res, next) =&gt; {\n    res.json({ ...req.body });\n  });\n  app.get(`${v}/pets`, (req, res, next) =&gt; {\n    res.json([\n      {\n        id: 1,\n        name: 'happy',\n        type: 'cat',\n      },\n    ]);\n  });\n\n  app.use((err, req, res, next) =&gt; {\n    // format error\n    res.status(err.status || 500).json({\n      message: err.message,\n      errors: err.errors,\n    });\n  });\n}\n\nfunction routesV2(app) {\n  const v = '/v2';\n  app.get(`${v}/pets`, (req, res, next) =&gt; {\n    res.json([\n      {\n        pet_id: 1,\n        pet_name: 'happy',\n        pet_type: 'kitty',\n      },\n    ]);\n  });\n  app.post(`${v}/pets`, (req, res, next) =&gt; {\n    res.json({ ...req.body });\n  });\n\n  app.use((err, req, res, next) =&gt; {\n    // format error\n    res.status(err.status || 500).json({\n      message: err.message,\n      errors: err.errors,\n    });\n  });\n}\n\nmodule.exports = app;\n</code></pre>"},{"location":"rest/#faq","title":"FAQ","text":"<p>Q: How do I match paths, like those described in RFC-6570?</p> <p>A: OpenAPI 3.0 does not support RFC-6570. That said, we provide a minimalistic mechanism that conforms syntactically to OpenAPI 3 and accomplishes a common use case. For example, matching file paths and storing the matched path in <code>req.params</code></p> <p>Using the following OpenAPI 3.x definition</p> <pre><code>/files/{path}*:\n  get:\n    parameters:\n      - name: path\n        in: path\n        required: true\n        schema:\n          type: string\n</code></pre> <p>With the following Express route definition</p> <pre><code>  app.get(`/files/:path(*)`, (req, res) =&gt; { /* do stuff */ }`\n</code></pre> <p>A path like <code>/files/some/long/path</code> will pass validation. The Express <code>req.params.path</code> property will hold the value <code>some/long/path</code>.</p> <p>Q: Can I use discriminators with <code>oneOf</code> and <code>anyOf</code>?</p> <p>A: Currently, there is support for top level discriminators. See top-level discriminator example</p> <p>Q: What happened to the <code>securityHandlers</code> property?</p> <p>A: In v3, <code>securityHandlers</code> have been replaced by <code>validateSecurity.handlers</code>. To use v3 security handlers, move your existing security handlers to the new property. No other change is required. Note that the v2 <code>securityHandlers</code> property is supported in v3, but deprecated</p> <p>Q: What happened to the <code>multerOpts</code> property?</p> <p>A: In v3, <code>multerOpts</code> have been replaced by <code>fileUploader</code>. In order to use the v3 <code>fileUploader</code>, move your multer options to <code>fileUploader</code> No other change is required. Note that the v2 <code>multerOpts</code> property is supported in v3, but deprecated</p> <p>Q: I can disallow unknown query parameters with <code>allowUnknownQueryParameters: false</code>. How can disallow unknown body parameters?</p> <p>A: Add <code>additionalProperties: false</code> when describing e.g a <code>requestBody</code> to ensure that additional properties are not allowed. For example:</p> <pre><code>Pet:\nadditionalProperties: false\nrequired:\n  - name\nproperties:\n  name:\n    type: string\n  type:\n    type: string\n</code></pre> <p>Q: Can I use <code>express-openapi-validator</code> with <code>swagger-ui-express</code>?</p> <p>A: Yes. Be sure to <code>use</code> the <code>swagger-ui-express</code> serve middleware prior to installing <code>OpenApiValidator</code>. This will ensure that <code>swagger-ui-express</code> is able to fully prepare the spec before before OpenApiValidator attempts to use it. For example:</p> <pre><code>const swaggerUi = require('swagger-ui-express')\nconst OpenApiValidator = require('express-openapi-validator')\n\n...\n\napp.use('/', swaggerUi.serve, swaggerUi.setup(documentation))\n\napp.use(OpenApiValidator.middleware({\n  apiSpec, // api spec JSON object\n  //... other options\n  }\n}))\n</code></pre> <p>Q: I have a handler function defined on an <code>express.Router</code>. If i call <code>req.params</code> each param value has type <code>string</code>. If i define same handler function on an <code>express.Application</code>, each value in <code>req.params</code> is already coerced to the type declare in my spec. Why not coerce theseF values on an <code>express.Router</code>?</p> <p>A: First, it's important to note that this behavior does not impact validation. The validator will validate against the type defined in your spec.</p> <p>In order to modify the <code>req.params</code>, express requires that a param handler be registered e.g. <code>app.param(...)</code> or <code>router.param(...)</code>. Since <code>app</code> is available to middleware functions, the validator registers an <code>app.param</code> handler to coerce and modify the values of <code>req.params</code> to their declared types. Unfortunately, express does not provide a means to determine the current router from a middleware function, hence the validator is unable to register the same param handler on an express router. Ultimately, this means if your handler function is defined on <code>app</code>, the values of <code>req.params</code> will be coerced to their declared types. If your handler function is declare on an <code>express.Router</code>, the values of <code>req.params</code> values will be of type <code>string</code> (You must coerce them e.g. <code>parseInt(req.params.id)</code>).</p>"},{"location":"rest/#related-projects","title":"Related Projects","text":"<ul> <li>koa-openapi-validator</li> <li>fastify-openapi-validator</li> </ul> <p>_Note: koa and fastify does not (yet) support response validation or operation handlers</p>"},{"location":"rest/#contributors","title":"Contributors \u2728","text":"<p>Contributions welcome! Here's how to contribute.</p> <p>Thanks goes to these wonderful people (emoji key):</p> <sub>Carmine DiMascio</sub>\ud83d\udcbb \u26a0\ufe0f \ud83d\ude87 <sub>Sheldhur Mornor</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Andrey Trebler</sub>\ud83d\udcbb \u26a0\ufe0f <sub>richdouglasevans</sub>\ud83d\udcd6 <sub>Miran Setinc</sub>\ud83d\udcbb <sub>Frank Calise</sub>\ud83d\udcbb <sub>Gonen Dukas</sub>\ud83e\udd14 \u26a0\ufe0f <sub>Sven Eliasson</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Spencer Brown</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Jos\u00e9 Neves</sub>\ud83d\udcbb <sub>mk811</sub>\ud83d\udcbb \u26a0\ufe0f <sub>HugoMario</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Rowan Cockett</sub>\ud83d\udcbb <sub>Jacques Yakoub</sub>\ud83d\udcbb <sub>ckeboss</sub>\ud83d\udcbb \u26a0\ufe0f <sub>JacobLey</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Dmitriy Voeykov</sub>\ud83d\udcbb \u26a0\ufe0f <sub>GARAMKIM</sub>\ud83d\udcbb \ud83e\udd14 <sub>Mathias Scherer</sub>\ud83d\udcbb <sub>Mirek</sub>\ud83d\udcbb <sub>Florian Beutel</sub>\ud83d\udcbb <sub>jakubskopal</sub>\ud83d\udcbb \u26a0\ufe0f \ud83d\udcd6 <sub>Jordan Dobrev</sub>\u26a0\ufe0f \ud83d\udcbb <sub>Enrico Fabris</sub>\ud83d\udcbb <sub>Dustin Wheeler</sub>\ud83d\udcbb \ud83d\udcd6 \u26a0\ufe0f <sub>Thomas Carmichael</sub>\ud83d\udcd6 <sub>Jakesterwars</sub>\ud83d\udcd6 <sub>xtrycatchx</sub>\ud83d\udcbb <sub>Lee Dong Joo</sub>\ud83d\udcd6 <sub>Dmitry Chekanov</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Redhart Azul</sub>\ud83d\udcbb <sub>Joost Diepenmaat</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Dom Parfitt</sub>\ud83d\udcbb \u26a0\ufe0f <sub>xg1990</sub>\ud83d\udcbb <sub>ownagedj</sub>\ud83d\udcbb \u26a0\ufe0f <sub>David Garner</sub>\ud83d\udcbb <sub>Balazs Soltesz</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Christiaan Nieuwlaat</sub>\ud83d\udcbb <sub>Ilya</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Yuliya Bagriy</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Kristjan Siimson</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Guillaume</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Volodymyr Kolesnykov</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Pierre Le Roux</sub>\ud83d\udcbb \u26a0\ufe0f \ud83e\udd14 <sub>Electro Type</sub>\ud83e\udd14 <sub>Aaron Luman</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Aymeric Robini</sub>\ud83d\udcbb \u26a0\ufe0f <sub>lyndoh</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Dakota</sub>\ud83d\udcbb <sub>Robert Jones</sub>\ud83d\udcbb \u26a0\ufe0f <sub>Alberto Alonso</sub>\ud83d\udcbb <sub>Gabriel Zerbib</sub>\ud83d\udcbb \u26a0\ufe0f <p>This project follows the all-contributors specification. Contributions of any kind welcome!</p>"},{"location":"rest/#community-articles-blogs-and-tutorials","title":"Community articles, blogs, and tutorials","text":"<p>Seeking content creators...</p> <p>Have you written an article, blog, or tutorial that uses <code>express-openapi-validator</code>?</p> <p>Please post your links here</p> <p>We plan to publicize a variety of links here.</p>"},{"location":"rest/#license","title":"License","text":"<p>MIT</p> <p></p>"},{"location":"upgrading/","title":"Upgrading","text":""},{"location":"upgrading/#upgrading-from-3x","title":"Upgrading from 3.x","text":"<p>In v4.x.x, the validator is installed as standard connect middleware using <code>app.use(...) and/or router.use(...)</code> (example). This differs from the v3.x.x the installation which required the <code>install</code> method(s). The <code>install</code> methods no longer exist in v4.</p>"},{"location":"usage-advanced/","title":"Advanced usage and options","text":""},{"location":"usage-advanced/#advanced-usage","title":"Advanced Usage","text":""},{"location":"usage-advanced/#openapivalidator-middleware-options","title":"OpenApiValidator Middleware Options","text":"<p>express-openapi validator provides a good deal of flexibility via its options.</p> <p>Options are provided via the options object. Options take the following form:</p> <pre><code>OpenApiValidator.middleware({\n  apiSpec: './openapi.yaml',\n  validateRequests: true,\n  validateResponses: true,\n  validateApiSpec: true,\n  validateSecurity: {\n    handlers: {\n      ApiKeyAuth: (req, scopes, schema) =&gt; {\n        throw { status: 401, message: 'sorry' }\n      }\n    }\n  },\n  validateFormats: 'fast',\n  formats: [{\n    name: 'my-custom-format',\n    type: 'string' | 'number',\n    validate: (value: any) =&gt; boolean,\n  }],\n  unknownFormats: ['phone-number', 'uuid'],\n  serDes: [\n    OpenApiValidator.serdes.dateTime,\n    OpenApiValidator.serdes.date,\n    {\n      format: 'mongo-objectid',\n      deserialize: (s) =&gt; new ObjectID(s),\n      serialize: (o) =&gt; o.toString(),\n    },\n  ],\n  operationHandlers: false | 'operations/base/path' | { ... },\n  ignorePaths: /.*\\/pets$/,\n  ignoreUndocumented: false,\n  fileUploader: { ... } | true | false,\n  $refParser: {\n    mode: 'bundle'\n  },\n});\n</code></pre>"},{"location":"usage-api-spec/","title":"\u25aa\ufe0f apiSpec (required)","text":"<p>Specifies the path to an OpenAPI 3 specification or a JSON object representing the OpenAPI 3 specification</p> <p>Option-schema</p> <pre><code>apiSpec: '/path/to/spec.yaml' | { \n  /*openapi-spec-json */\n}\n</code></pre>"},{"location":"usage-api-spec/#apispec","title":"<code>apiSpec</code>","text":"<p>Takes a path to a API specification or the API specification object.</p> <pre><code>apiSpec: './path/to/my-openapi-spec.yaml',\n</code></pre> <p>or</p> <pre><code>apiSpec: {\n  openapi: '3.0.1',\n  info: {...},\n  servers: [...],\n  paths: {...},\n  components: {\n    responses: {...},\n    schemas: {...}\n  }\n}\n</code></pre>"},{"location":"usage-coerce-types/","title":"\u25aa\ufe0f coerceTypes (deprecated)","text":"<p>Warning</p> <p><code>coerceTypes</code> is deprecated in favor of validateRequests.coerceTypes and validateResponses.coerceTypes</p> <p>Determines whether the validator should coerce value types to match the those defined in the OpenAPI spec. This option applies only to path params, query strings, headers, and cookies. It is highly unlikely that you will want to disable this. As such this option is deprecated and will be removed in the next major version</p> <p>Option-schema</p> <pre><code>    coerceTypes: true | 'array'\n</code></pre>"},{"location":"usage-coerce-types/#coercetypes-optional-deprecated","title":"coerceTypes (optional) - deprecated","text":"<ul> <li><code>true</code> (default) - coerce scalar data types.</li> <li><code>\"array\"</code> - in addition to coercions between scalar types, coerce scalar data to an array with one element and vice versa (as required by the schema).</li> </ul>"},{"location":"usage-file-uploader/","title":"\u25aa\ufe0f fileUploader","text":"<p>Specifies the options to passthrough to multer. express-openapi-validator uses multer to handle file uploads. see multer opts</p> <p>Option-schema</p> <pre><code>fileUploader: true | false | {\n  dest: `/path/to/uploads`\n}\n</code></pre>"},{"location":"usage-file-uploader/#fileuploader-optional","title":"fileUploader (optional)","text":"<ul> <li><code>true</code> (default) - enables multer and provides simple file(s) upload capabilities</li> <li><code>false</code> - disables file upload capability. Upload capabilities may be provided by the user</li> <li><code>{...}</code> - multer options to be passed-through to multer. see multer opts for possible options</li> </ul> <p>e.g.</p> <pre><code>fileUploader: {\n  dest: 'uploads/',\n}\n</code></pre>"},{"location":"usage-formats/","title":"\u25aa\ufe0f formats","text":"<p>Defines a list of custom formats.</p> <p>Option-schema</p> <pre><code>formats: [{ name, type, validate: (v): boolean }]\n</code></pre>"},{"location":"usage-formats/#formats-optional","title":"formats (optional)","text":"<ul> <li><code>[{ ... }]</code> - array of custom format objects. Each object must have the following properties:</li> <li>name: string (required) - the format name</li> <li>validate: (v: any) =&gt; boolean (required) - the validation function</li> <li>type: 'string' | 'number' (optional) - the format's type</li> </ul> <p>e.g.</p> <pre><code>formats: [\n  {\n    name: 'my-three-digit-format',\n    type: 'number',\n    // validate returns true the number has 3 digits, false otherwise\n    validate: (v) =&gt; /^\\d{3}$/.test(v.toString()),\n  },\n  {\n    name: 'my-three-letter-format',\n    type: 'string',\n    // validate returns true the string has 3 letters, false otherwise\n    validate: (v) =&gt; /^[A-Za-z]{3}$/.test(v),\n  },\n];\n</code></pre> <p>Then use it in a spec e.g.</p> <pre><code>my_property:\n  type: string\n  format: my-three-letter-format'\n</code></pre>"},{"location":"usage-ignore-paths/","title":"\u25aa\ufe0f ignorePaths","text":"<p>Defines a regular expression or function that determines whether a path(s) should be ignored. If it's a regular expression, any path that matches the regular expression will be ignored by the validator. If it's a function, it will ignore any paths that returns a truthy value.</p> <p>The following ignores any path that ends in <code>/pets</code> e.g. <code>/v1/pets</code>. As a regular expression:</p> <p>Option-schema</p> <pre><code>ignorePaths: &lt;regex&gt; | (path: string): boolean\n</code></pre>"},{"location":"usage-ignore-paths/#ignorepaths-optional","title":"ignorePaths (optional)","text":"<pre><code>ignorePaths: /.*\\/pets$/\n</code></pre> <p>or as a function:</p> <pre><code>ignorePaths: (path) =&gt; path.endsWith('/pets')\n</code></pre>"},{"location":"usage-ignore-undocumented/","title":"\u25aa\ufe0f ignoreUndocumented","text":"<p>Disables any form of validation for requests which are not documented in the OpenAPI spec.</p> <p>Option-schema</p> <pre><code>ignoreUndcoumented: false | true\n</code></pre>"},{"location":"usage-ignore-undocumented/#ignoreundocumented-optional","title":"ignoreUndocumented (optional)","text":"<pre><code>- `false` - fail validate for undocumented apis\n- `true` - ignore undocumented api\n</code></pre>"},{"location":"usage-operation-handlers/","title":"\u25aa\ufe0f operationHandlers","text":"<p>Defines the base directory for operation handlers. This is used in conjunction with express-openapi-validator's OpenAPI vendor extensions, <code>x-eov-operation-id</code>, <code>x-eov-operation-handler</code> and OpenAPI's <code>operationId</code>. See example.</p> <p>Additionally, if you want to change how modules are resolved e.g. use dot delimited operation ids e.g. <code>path.to.module.myFunction</code>, you may optionally add a custom <code>resolver</code>. See documentation and example</p> <p>Option-schema</p> <pre><code>operationHandlers: false | '/path/to/handlers' | {\n    basePath: '/path/to/handlers'\n    resolver: (modulePath, route): : express.RequestHandler \n}\n</code></pre>"},{"location":"usage-operation-handlers/#operationhandlers-optional","title":"operationHandlers (optional)","text":"<ul> <li><code>string</code> - the base directory containing operation handlers</li> <li><code>false</code> - (default) disable auto wired operation handlers</li> <li> <p><code>{ ... }</code> - specifies a base directory and optionally a custom resolver</p> <p>For example:</p> <pre><code>operationHandlers: {\n    basePath: __dirname,\n    resolver: function (modulePath, route): express.RequestHandler {\n    ///...\n    }\n}\n</code></pre> </li> </ul>"},{"location":"usage-operation-handlers/#openapi-vendor-extensions","title":"OpenAPI Vendor extensions","text":""},{"location":"usage-operation-handlers/#x-eov-operation-handler","title":"x-eov-operation-handler","text":"<p>Note</p> <p>The <code>x-eov-operation-handler</code> OpenAPI vendor extension specifies a path relative to <code>operationHandlers</code>. Thus if <code>operationHandlers</code> is <code>/handlers</code> and an <code>x-eov-operation-handler</code> has path <code>routes/ping</code>, then the handler file <code>/handlers/routes/ping.js</code> (or <code>ts</code>) is used.</p> <p>Complete example here</p> <p>api.yaml</p> <pre><code>/ping:\n  get:\n    description: |\n      ping then pong!\n    # OpenAPI's operationId may be used to to specify the operation id\n    operationId: ping\n    # x-eov-operation-id may be used to specify the operation id\n    # Used when operationId is omitted. Overrides operationId when both are specified\n    x-eov-operation-id: ping\n    # specifies the path to the operation handler.\n    # the path is relative to the operationHandlers option\n    # e.g. operations/base/path/routes/ping.js\n    x-eov-operation-handler: routes/ping\n    responses:\n      '200':\n        description: OK\n        # ...\n</code></pre> <p>routes/ping.js</p> <p><code>x-eov-operation-handler</code> specifies the path to this handlers file, <code>ping.js</code></p> <p><code>x-eov-operation-id</code> (or <code>operationId</code>) specifies operation handler's key e.g. <code>ping</code></p> <pre><code>module.exports = {\n  ping: (req, res) =&gt; res.status(200).send('pong'),\n};\n</code></pre>"},{"location":"usage-options-summary/","title":"All Options","text":""},{"location":"usage-options-summary/#openapivalidator-middleware-options","title":"OpenApiValidator Middleware Options","text":"<p>The <code>express-openapi-validator</code> middleware provides sensible defaults, requiring minimal upfront configuration. However, it also provides flexibility and customization through a vast array of parameters and options.</p> <p>The following example includes the complete set of customizable options. Each option is explained in detail within its options usage page.</p> <pre><code>OpenApiValidator.middleware({\n  apiSpec: './openapi.yaml',\n  validateRequests: true,\n  validateResponses: true,\n  validateApiSpec: true,\n  validateSecurity: {\n    handlers: {\n      ApiKeyAuth: (req, scopes, schema) =&gt; {\n        throw { status: 401, message: 'sorry' }\n      }\n    }\n  },\n  validateFormats: 'fast',\n  formats: [{\n    name: 'my-custom-format',\n    type: 'string' | 'number',\n    validate: (value: any) =&gt; boolean,\n  }],\n  unknownFormats: ['phone-number', 'uuid'],\n  serDes: [\n    OpenApiValidator.serdes.dateTime,\n    OpenApiValidator.serdes.date,\n    {\n      format: 'mongo-objectid',\n      deserialize: (s) =&gt; new ObjectID(s),\n      serialize: (o) =&gt; o.toString(),\n    },\n  ],\n  operationHandlers: false | 'operations/base/path' | { ... },\n  ignorePaths: /.*\\/pets$/,\n  ignoreUndocumented: false,\n  fileUploader: { ... } | true | false,\n  $refParser: {\n    mode: 'bundle'\n  },\n});\n</code></pre>"},{"location":"usage-ref-parser/","title":"\u25aa\ufe0f $refParser","text":"<p>Determines how JSON schema references are resolved by the internal json-schema-ref-parser. Generally, the default mode, <code>bundle</code> is sufficient, however if you use escape characters in \\$refs, <code>dereference</code> is necessary.</p> <p>Option-schema</p> <pre><code>#refParser: {\n    mode: 'bundle' | 'dereference'\n}\n</code></pre>"},{"location":"usage-ref-parser/#refparsermode-optional","title":"$refParser.mode (optional)","text":"<ul> <li><code>bundle</code> (default) - Bundles all referenced files/URLs into a single schema that only has internal $ref pointers. This eliminates the risk of circular references, but does not handle escaped characters in $refs.</li> <li><code>dereference</code> - Dereferences all $ref pointers in the JSON Schema, replacing each reference with its resolved value. Introduces risk of circular $refs. Handles escape characters in \\$refs)</li> </ul> <p>Tip</p> <p><code>dereference</code>, for some use cases, proves more reliable, however it cannot handle circular types.</p> <p>See this issue for more information.</p> <pre><code>$refParser: {\n  mode: 'bundle',\n}\n</code></pre>"},{"location":"usage-remove-additional/","title":"\u25aa\ufe0f removeAdditional (options)","text":"<p>Determines whether to keep or remove additional properties in request body or to fail validation if schema has <code>additionalProperties</code> set to <code>false</code>. For further details, refer to AJV documentation</p> <ul> <li><code>false</code> (default) - not to remove additional properties</li> <li><code>\"all\"</code> - all additional properties are removed, regardless of additionalProperties keyword in schema (and no validation is made for them).</li> <li><code>true</code> - only additional properties with additionalProperties keyword equal to false are removed.</li> <li><code>\"failing\"</code> - additional properties that fail request schema validation will be removed (where additionalProperties keyword is false or schema).</li> </ul> <p>For example:</p> <pre><code>validateRequests: {\nremoveAdditional: true,\n}\n</code></pre>"},{"location":"usage-serdes/","title":"\u25aa\ufe0f serDes","text":"<p>Defines custom serialization and deserialization behavior for schemas of type <code>string</code> that declare a <code>format</code>. By default, <code>Date</code> objects are serialized as <code>string</code> when a schema's <code>type</code> is <code>string</code> and <code>format</code> is <code>date</code> or <code>date-time</code>.</p> <p>Option-schema</p> <pre><code>serDes: [\n    // installs dateTime serializer and deserializer\n    OpenApiValidator.serdes.dateTime,\n    // installs date serializer and deserializer\n    OpenApiValidator.serdes.date,\n    // custom serializer and deserializer for the custom format, mongo-objectid\n    {\n        format: 'mongo-objectid',\n        deserialize: (s) =&gt; new ObjectID(s),\n        serialize: (o) =&gt; o.toString(),\n    },\n],\n</code></pre> <p>e.g.</p> <pre><code>// If `serDes` is not specified, the following behavior is default\nserDes: [\n  OpenApiValidator.serdes.dateTime.serializer,\n  OpenApiValidator.serdes.date.serializer,\n],\n</code></pre>"},{"location":"usage-serdes/#serdes-optional","title":"serDes (optional)","text":"<p>To create custom serializers and/or deserializers, define:</p> <ul> <li><code>format</code> (required) - a custom 'unknown' format that triggers the serializer and/or deserializer</li> <li><code>deserialize</code> (optional) - upon receiving a request, transform a string property to an object. Deserialization occurs after request schema validation.</li> <li><code>serialize</code> (optional) - before sending a response, transform an object to string. Serialization occurs after response schema validation</li> <li><code>jsonType</code> (optional, default 'object') - set to override for deserialized types that are not 'object', eg 'array'</li> </ul> <p>e.g.</p> <pre><code>serDes: [\n   // installs dateTime serializer and deserializer\n  OpenApiValidator.serdes.dateTime,\n  // installs date serializer and deserializer\n  OpenApiValidator.serdes.date,\n  // custom serializer and deserializer for the custom format, mongo-objectid\n  {\n    format: 'mongo-objectid',\n    deserialize: (s) =&gt; new ObjectID(s),\n    serialize: (o) =&gt; o.toString(),\n  },\n],\n</code></pre> <p>The mongo serializers will trigger on the following schema:</p> <pre><code>type: string\nformat: mongo-objectid\n</code></pre> <p>See mongo-serdes-js for additional (de)serializers including MongoDB <code>ObjectID</code>, <code>UUID</code>, ...</p>"},{"location":"usage-standard/","title":"Usage standard","text":"<pre><code>const express = require('express');\nconst path = require('path');\nconst http = require('http');\nconst app = express();\n\n// 1. Import the express-openapi-validator library\nconst OpenApiValidator = require('express-openapi-validator');\n\n// 2. Set up body parsers for the request body types you expect\n//    Must be specified prior to endpoints in 5.\napp.use(express.json());\napp.use(express.text());\napp.use(express.urlencoded({ extended: false }));\n\n// 3. (optionally) Serve the OpenAPI spec\nconst spec = path.join(__dirname, 'api.yaml');\napp.use('/spec', express.static(spec));\n\n// 4. Install the OpenApiValidator onto your express app\napp.use(\n  OpenApiValidator.middleware({\n    apiSpec: './api.yaml',\n    validateResponses: true, // &lt;-- to validate responses\n  }),\n);\n\n// 5. Define routes using Express\napp.get('/v1/pets', function (req, res, next) {\n  res.json([\n    { id: 1, type: 'cat', name: 'max' },\n    { id: 2, type: 'cat', name: 'mini' },\n  ]);\n});\n\napp.post('/v1/pets', function (req, res, next) {\n  res.json({ name: 'sparky', type: 'dog' });\n});\n\napp.get('/v1/pets/:id', function (req, res, next) {\n  res.json({ id: req.params.id, type: 'dog', name: 'sparky' });\n});\n\n// 5a. Define route(s) to upload file(s)\napp.post('/v1/pets/:id/photos', function (req, res, next) {\n  // files are found in req.files\n  // non-file multipart params can be found as such: req.body['my-param']\n  res.json({\n    files_metadata: req.files.map((f) =&gt; ({\n      originalname: f.originalname,\n      encoding: f.encoding,\n      mimetype: f.mimetype,\n      // Buffer of file conents\n      buffer: f.buffer,\n    })),\n  });\n});\n\n// 6. Create an Express error handler\napp.use((err, req, res, next) =&gt; {\n  // 7. Customize errors\n  console.error(err); // dump error to console for debug\n  res.status(err.status || 500).json({\n    message: err.message,\n    errors: err.errors,\n  });\n});\n\nhttp.createServer(app).listen(3000);\n</code></pre>"},{"location":"usage-unknown-formats/","title":"\u25aa\ufe0f unknownFormats","text":"<p>Defines how the validator should behave if an unknown or custom format is encountered.</p> <p>Option-schema</p> <pre><code>unknownFormats: true 'ignore' | ['&lt;format&gt;', ...]\n</code></pre>"},{"location":"usage-unknown-formats/#unknownformats-optional","title":"unknownFormats (optional)","text":"<ul> <li><code>true</code> (default) - When an unknown format is encountered, the validator will report a 400 error.</li> <li> <p><code>[string]</code> (recommended for unknown formats) - An array of unknown format names that will be ignored by the validator. This option can be used to allow usage of third party schemas with format(s), but still fail if another unknown format is used.</p> <pre><code>unknownFormats: ['phone-number', 'uuid'],\n</code></pre> </li> <li> <p><code>\"ignore\"</code> - to log warning during schema compilation and always pass validation. This option is not recommended, as it allows to mistype format name and it won't be validated without any error message.</p> </li> </ul>"},{"location":"usage-validate-api-spec/","title":"\u25aa\ufe0f validateApiSpec","text":"<p>Determines whether the validator should validate the OpenAPI specification. Useful if you are certain that the api spec is syntactically correct and want to bypass this check.</p> <p>Warning: Be certain your spec is valid. And be sure you know what you're doing! express-openapi-validator expects a valid spec. If incorrect, the validator will behave erratically and/or throw Javascript errors.</p> <p>Option-schema</p> <pre><code>{\n    validateApiSpec: true | false\n}\n</code></pre>"},{"location":"usage-validate-api-spec/#validateapispec-optional","title":"validateApiSpec (optional)","text":"<ul> <li><code>true</code> (default) - validate the OpenAPI specification.</li> <li><code>false</code> - do not validate the OpenAPI specification.</li> </ul>"},{"location":"usage-validate-formats/","title":"\u25aa\ufe0f validateFormats","text":"<p>Specifies the strictness of validation of string formats.</p> <p>Note</p> <pre><code>validateFormats: 'fast' | 'full' | false\n</code></pre>"},{"location":"usage-validate-formats/#validateformats-optional","title":"validateFormats (optional)","text":"<ul> <li><code>\"fast\"</code> (default) - only validate syntax, but not semantics. E.g. <code>2010-13-30T23:12:35Z</code> will pass validation even though it contains month 13.</li> <li><code>\"full\"</code> - validate both syntax and semantics. Illegal dates will not pass.</li> <li><code>false</code> - do not validate formats at all.</li> </ul>"},{"location":"usage-validate-requests/","title":"\u25aa\ufe0f validateRequests","text":"<p>Determines whether the validator should validate requests.</p> <p>Option-schema</p> <pre><code>validateRequests: true | false | {\n    allowUnknownQueryParameters: false | true,\n    coerceTypes: false | true | 'array',\n    removeAdditional: false | true | 'all' | 'failing',\n    allErrors: false | true,\n    discriminator: false | true,\n}\n</code></pre>"},{"location":"usage-validate-requests/#validaterequests-optional","title":"validateRequests (optional)","text":"<ul> <li><code>true</code> (default) - validate requests.</li> <li><code>false</code> - do not validate requests.</li> <li> <p><code>{ ... }</code> - validate requests with options</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>This option was introduced in version 5.6.0 to extend support for OpenAPI discriminators.</p> <p>Enables validation of schemas that use OpenAPI <code>discriminator</code> fields with <code>oneOf</code> / <code>anyOf</code>.</p> <p>By default, only top-level discriminators are supported.   When this option is enabled, the validator also supports deep (nested) discriminators inside <code>oneOf</code> / <code>anyOf</code> structures.</p> <p>Option Schema <pre><code>discriminator: false | true\n</code></pre></p> <pre><code>- `true` \u2013 enable validation of both top-level and deep discriminators\n- `false` \u2013 (**default**) only top-level discriminators are validated\n</code></pre> <p>Example <pre><code>app.use(\n  OpenApiValidator.middleware({\n    apiSpec,\n    validateRequests: {\n      discriminator: true,\n    }\n  })\n);\n</code></pre></p> </li> </ul>"},{"location":"usage-validate-requests/#coercetypes","title":"<code>coerceTypes</code>","text":"<p>Determines whether the validator will coerce the request body. Request query and path params, headers, cookies are coerced by default and this setting does not affect that.</p> <p>See additional details on coercion and limitations.</p> <p>Option Schema <pre><code>coerceTypes: false | true | 'array'\n</code></pre></p> <ul> <li><code>true</code> - coerce scalar data types.</li> <li><code>false</code> - (default) do not coerce types. (more strict, safer)</li> <li><code>\"array\"</code> - in addition to coercions between scalar types, coerce scalar data to an array with one element and vice versa (as required by the schema).</li> </ul>"},{"location":"usage-validate-requests/#allowunknownqueryparameters","title":"<code>allowUnknownQueryParameters</code>","text":"<p>Determines whether to allow undefined query parameters to pass validation.</p> <p>Option Schema <pre><code>allowUnknownQueryParameters: false | true\n</code></pre></p> <ul> <li><code>true</code> - enables unknown/undeclared query parameters to pass validation</li> <li><code>false</code> - (default) fail validation if an unknown query parameter is present</li> </ul> <p>Note</p> <p><code>allowUnknownQueryParameters</code> is set for the globally on the validator. It can be overwritten on a per-operation basis by using the custom OpenAPI vendor extension <code>x-allow-unknown-query-parameters</code>.</p> <p>The following example allows unknown query parameters for the annotated endpoint:</p> <pre><code>paths:\n  /allow_unknown:\n    get:\n      x-allow-unknown-query-parameters: true ## &lt;--- overrides the global setting\n      parameters:\n        - name: value\n          in: query\n          schema:\n          type: string\n      responses:\n        200:\n          description: success\n</code></pre>"},{"location":"usage-validate-requests/#removeadditional","title":"<code>removeAdditional</code>","text":"<p>Determines whether to keep or remove additional properties in request body or to fail validation if schema has <code>additionalProperties</code> set to <code>false</code>. For further details, refer to AJV documentation</p> <p>Option Schema <pre><code>removeAdditional: false | true | 'all' | 'failing'\n</code></pre></p> <ul> <li><code>false</code> (default) - not to remove additional properties</li> <li><code>\"all\"</code> - all additional properties are removed, regardless of additionalProperties keyword in schema (and no validation is made for them).</li> <li><code>true</code> - only additional properties with additionalProperties keyword equal to false are removed.</li> <li><code>\"failing\"</code> - additional properties that fail request schema validation will be removed (where additionalProperties keyword is false or schema).</li> </ul>"},{"location":"usage-validate-requests/#allerrors","title":"<code>allErrors</code>","text":"<p>This option was introduced in version 5.3.4, where the default behavior of request validation was changed to stop after the first failure.</p> <p>Determine's whether all validation rules should be checked and all failures reported. By default, validation stops after the first failure. This option passes through to AJV, see AJV Options: allErrors.</p> <p>Do NOT use allErrors in production Following the recommended best practices by AJV, this option should be left unset, or set to <code>false</code> in production to help mitigate slow validations and potential ReDOS attacks.</p> <p>Option Schema <pre><code>allErrors: false | true\n</code></pre></p> <ul> <li><code>true</code> - all rules should be checked and all failures reported</li> <li><code>false</code> - (default) stop checking rules after the first failure</li> </ul>"},{"location":"usage-validate-requests/#discriminator","title":"<code>discriminator</code>","text":""},{"location":"usage-validate-responses/","title":"\u25aa\ufe0f validateResponses","text":"<p>Determines whether the validator should validate responses. Additionally, it accepts an object of configuragble response validation options.</p> <p>Option-schema</p> <pre><code>validateResponses: false | true | {\n    removeAdditional: 'failing',\n    coerceTypes: true | false | 'array',\n    onError: (error, body, req): void,\n    allErrors: false | true,\n}\n</code></pre>"},{"location":"usage-validate-responses/#validateresponses","title":"validateResponses","text":"<ul> <li><code>true</code> - validate responses in 'strict' mode i.e. responses MUST match the schema.</li> <li><code>false</code> (default) - do not validate responses</li> <li> <p><code>{ ... }</code> - validate responses with options</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> </ul> </li> </ul>"},{"location":"usage-validate-responses/#removeadditional","title":"<code>removeAdditional</code>","text":"<p>Determines whether the validator will remove additional properties, prior to validation.</p> <p>Options Schema <pre><code>removeAdditional: 'failing'\n</code></pre></p> <ul> <li><code>\"failing\"</code> - additional properties that fail schema validation are automatically removed from the response.</li> </ul>"},{"location":"usage-validate-responses/#coercetypes","title":"<code>coerceTypes</code>","text":"<ul> <li><code>true</code> - coerce scalar data types.</li> <li><code>false</code> - (default) do not coerce types. (almost always the desired behavior)</li> <li><code>\"array\"</code> - in addition to coercions between scalar types, coerce scalar data to an array with one element and vice versa (as required by the schema).</li> </ul>"},{"location":"usage-validate-responses/#onerror","title":"<code>onError</code>","text":"<ul> <li> <p><code>(error, body, req): void</code> - A function that will be invoked on response validation error, instead of the default handling. Useful if you want to log an error or emit a metric, but don't want to actually fail the request. Receives the validation error, the offending response body, and the express request object.</p> <p>For example:</p> <pre><code>validateResponses: {\n    onError: (error, body, req) =&gt; {\n        console.log(`Response body fails validation: `, error);\n        console.log(`Emitted from:`, req.originalUrl);\n        console.debug(body);\n    }\n}\n</code></pre> </li> </ul>"},{"location":"usage-validate-responses/#allerrors","title":"<code>allErrors</code>","text":"<p>This option was introduced in version 5.3.4, where the default behavior of response validation was changed to stop after the first failure.</p> <p>Determine's whether all validation rules should be checked and all failures reported. By default, validation stops after the first failure. This option passes through to AJV, see AJV Options: allErrors.</p> <p>Do NOT use allErrors in production Following the recommended best practices by AJV, this option should be left unset, or set to <code>false</code> in production to help mitigate slow validations and potential ReDOS attacks.</p> <p>Option Schema <pre><code>allErrors: false | true\n</code></pre></p> <ul> <li><code>true</code> - all rules should be checked and all failures reported</li> <li><code>false</code> - (default) stop checking rules after the first failure</li> </ul>"},{"location":"usage-validate-security/","title":"\u25aa\ufe0f validateSecurity","text":"<p>Determines whether the validator should validate securities e.g. apikey, basic, oauth2, openid, etc</p> <p>Option-schema</p> <pre><code>validateSecurity: true | false | {\n    handlers: {\n        [auth-type]: (req, scopes, schema): void\n    }\n}\n</code></pre>"},{"location":"usage-validate-security/#validatesecurity","title":"validateSecurity","text":"<ul> <li><code>true</code> (default) - validate security</li> <li><code>false</code> - do not validate security</li> <li><code>{ ... }</code> - validate security with <code>handlers</code>. See Security handlers doc.</li> </ul> <p>handlers:</p> <p>For example:</p> <pre><code>validateSecurity: {\n  handlers: {\n    ApiKeyAuth: function(req, scopes, schema) {\n      console.log('apikey handler throws custom error', scopes, schema);\n      throw Error('my message');\n    },\n  }\n}\n</code></pre>"},{"location":"validation-curl/","title":"Validation curl","text":""},{"location":"validation-curl/#api-validation-responses","title":"API Validation Responses","text":"<p>The curl invocations below demonstrate the default validation response output provided by <code>express-openapi-validator</code>. All responses can be customized by contributing a custom response handler. for example:</p> <pre><code>app.use((err, req, res, next) =&gt; {\n  // format error\n  res.status(err.status || 500).json({\n    message: err.message,\n    errors: err.errors,\n  });\n});\n</code></pre>"},{"location":"validation-curl/#examples","title":"Examples","text":""},{"location":"validation-curl/#query-parameters","title":"Query parameters","text":""},{"location":"validation-curl/#validates-a-query-parameter-with-a-value-constraint","title":"Validates a query parameter with a value constraint","text":"<pre><code>curl -s http://localhost:3000/v1/pets/as |jq\n{\n  \"message\": \"request.params.id should be integer\",\n  \"errors\": [\n    {\n      \"path\": \".params.id\",\n      \"message\": \"should be integer\",\n      \"errorCode\": \"type.openapi.validation\"\n    }\n  ]\n}\n</code></pre>"},{"location":"validation-curl/#validates-a-query-parameter-with-a-range-constraint","title":"Validates a query parameter with a range constraint","text":"<pre><code> curl -s 'http://localhost:3000/v1/pets?limit=25' |jq\n{\n  \"message\": \"request.query should have required property 'type', request.query.limit should be &lt;= 20\",\n  \"errors\": [\n    {\n      \"path\": \".query.type\",\n      \"message\": \"should have required property 'type'\",\n      \"errorCode\": \"required.openapi.validation\"\n    },\n    {\n      \"path\": \".query.limit\",\n      \"message\": \"should be &lt;= 20\",\n      \"errorCode\": \"maximum.openapi.validation\"\n    }\n  ]\n}\n</code></pre>"},{"location":"validation-curl/#authorization","title":"Authorization","text":""},{"location":"validation-curl/#api-key-validaiton","title":"API Key validaiton","text":"<pre><code> curl -s --request POST \\\n  --url http://localhost:3000/v1/pets \\\n  --data '{}' |jq\n{\n  \"message\": \"'X-API-Key' header required\",\n  \"errors\": [\n    {\n      \"path\": \"/v1/pets\",\n      \"message\": \"'X-API-Key' header required\"\n    }\n  ]\n}\n</code></pre> <p>Providing the <code>X-API-Key</code> header passes OpenAPI validation.</p> <p>Note: that your Express middleware or endpoint logic can then provide additional checks.</p> <pre><code>curl -XPOST http://localhost:3000/v1/pets \\\n  --header 'X-Api-Key: XXXXX' \\\n  --header 'content-type: application/json' \\\n  -d '{\"name\": \"spot\"}' | jq\n\n{\n  \"id\": 4,\n  \"name\": \"spot\"\n}\n</code></pre>"},{"location":"validation-curl/#headers","title":"Headers","text":""},{"location":"validation-curl/#content-type-validation","title":"content-type validation","text":"<pre><code>curl -s --request POST \\\n  --url http://localhost:3000/v1/pets \\\n  --header 'content-type: application/xml' \\\n  --header 'x-api-key: XXXX' \\\n  --data '{\n        \"name\": \"test\"\n}' |jq\n  \"message\": \"unsupported media type application/xml\",\n  \"errors\": [\n    {\n      \"path\": \"/v1/pets\",\n      \"message\": \"unsupported media type application/xml\"\n    }\n  ]\n}\n</code></pre>"},{"location":"validation-curl/#request-bodies","title":"Request bodies","text":""},{"location":"validation-curl/#validating-a-post-body","title":"Validating a POST body","text":"<pre><code>curl -s --request POST \\\n  --url http://localhost:3000/v1/pets \\\n  --header 'content-type: application/json' \\\n  --header 'x-api-key: XXXX' \\\n  --data '{}'|jq\n{\n  \"message\": \"request.body should have required property 'name'\",\n  \"errors\": [\n    {\n      \"path\": \".body.name\",\n      \"message\": \"should have required property 'name'\",\n      \"errorCode\": \"required.openapi.validation\"\n    }\n  ]\n}\n</code></pre>"},{"location":"validation-curl/#file-upload-out-of-the-box","title":"File Upload (out of the box)","text":"<pre><code>curl -XPOST http://localhost:3000/v1/pets/10/photos -F file=@app.js|jq\n{\n  \"files_metadata\": [\n    {\n      \"originalname\": \"app.js\",\n      \"encoding\": \"7bit\",\n      \"mimetype\": \"application/octet-stream\"\n    }\n  ]\n}\n</code></pre>"},{"location":"validation-curl/#response-validation-optional","title":"Response validation (optional)","text":""},{"location":"validation-curl/#response-bodies","title":"Response bodies","text":"<p>Errors in response validation return <code>500</code>, not of <code>400</code></p> <p><code>/v1/pets/99</code> will return a response that does not match the spec</p> <pre><code> curl -s 'http://localhost:3000/v1/pets/99' |jq\n{\n  \"message\": \".response should have required property 'name', .response should have required property 'id'\",\n  \"errors\": [\n    {\n      \"path\": \".response.name\",\n      \"message\": \"should have required property 'name'\",\n      \"errorCode\": \"required.openapi.validation\"\n    },\n    {\n      \"path\": \".response.id\",\n      \"message\": \"should have required property 'id'\",\n      \"errorCode\": \"required.openapi.validation\"\n    }\n  ]\n}\n</code></pre>"},{"location":"validation-curl/#and-much-more-try-it-out","title":"...and much more. Try it out!","text":""}]}